diff --git a/Android.mk b/Android.mk
index fa5c38f..312db33 100644
--- a/Android.mk
+++ b/Android.mk
@@ -1,7 +1,6 @@
-ifneq ($(filter msm8960,$(TARGET_BOARD_PLATFORM)),)
-
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
 display-hals := libgralloc libgenlock libcopybit
-display-hals += libhwcomposer liboverlay libqdutils libexternal libqservice
+display-hals += libqdutils libexternal libqservice
 ifneq ($(TARGET_PROVIDES_LIBLIGHT),true)
 display-hals += liblight
 endif
diff --git a/common.mk b/common.mk
index ed8edc3..2a46540 100644
--- a/common.mk
+++ b/common.mk
@@ -1,10 +1,10 @@
 #Common headers
 common_includes := hardware/qcom/display/libgralloc
 common_includes += hardware/qcom/display/libgenlock
-common_includes += hardware/qcom/display/liboverlay
+common_includes += device/samsung/cooper/liboverlay
+common_includes += device/samsung/cooper/libhwcomposer
 common_includes += hardware/qcom/display/libcopybit
 common_includes += hardware/qcom/display/libqdutils
-common_includes += hardware/qcom/display/libhwcomposer
 common_includes += hardware/qcom/display/libexternal
 common_includes += hardware/qcom/display/libqservice
 
@@ -31,6 +31,10 @@ ifeq ($(ARCH_ARM_HAVE_NEON),true)
     common_flags += -D__ARM_HAVE_NEON
 endif
 
+ifeq ($(TARGET_NO_HW_VSYNC),true)
+    common_flags += -DNO_HW_VSYNC
+endif
+
 common_deps  :=
 kernel_includes :=
 
diff --git a/libgralloc/Android.mk b/libgralloc/Android.mk
index ae745f2..2b8f634 100644
--- a/libgralloc/Android.mk
+++ b/libgralloc/Android.mk
@@ -24,7 +24,6 @@ LOCAL_C_INCLUDES              := $(common_includes)
 LOCAL_SHARED_LIBRARIES        := $(common_libs) libmemalloc libgenlock
 LOCAL_SHARED_LIBRARIES        += libqdutils libGLESv1_CM
 LOCAL_CFLAGS                  := $(common_flags) -DLOG_TAG=\"gralloc\"
-LOCAL_ADDITIONAL_DEPENDENCIES := $(common_deps)
 LOCAL_SRC_FILES               :=  gpu.cpp gralloc.cpp framebuffer.cpp mapper.cpp
 include $(BUILD_SHARED_LIBRARY)
 
@@ -33,7 +32,14 @@ include $(CLEAR_VARS)
 LOCAL_MODULE           := libmemalloc
 LOCAL_MODULE_TAGS      := optional
 LOCAL_C_INCLUDES       := $(common_includes)
-LOCAL_SHARED_LIBRARIES := $(common_libs) libgenlock
+LOCAL_SHARED_LIBRARIES := $(common_libs) libgenlock libqdutils
 LOCAL_CFLAGS           := $(common_flags) -DLOG_TAG=\"memalloc\"
-LOCAL_SRC_FILES        :=  ionalloc.cpp alloc_controller.cpp
+LOCAL_SRC_FILES        := alloc_controller.cpp
+ifeq ($(TARGET_USES_ION),true)
+    LOCAL_SRC_FILES += ionalloc.cpp
+else
+    LOCAL_SRC_FILES += ashmemalloc.cpp \
+                       pmemalloc.cpp \
+                       pmem_bestfit_alloc.cpp
+endif
 include $(BUILD_SHARED_LIBRARY)
diff --git a/libgralloc/alloc_controller.cpp b/libgralloc/alloc_controller.cpp
index e4d1d68..04b0ffc 100644
--- a/libgralloc/alloc_controller.cpp
+++ b/libgralloc/alloc_controller.cpp
@@ -28,16 +28,30 @@
  */
 
 #include <cutils/log.h>
+#include <utils/RefBase.h>
 #include <fcntl.h>
 #include "gralloc_priv.h"
 #include "alloc_controller.h"
 #include "memalloc.h"
 #include "ionalloc.h"
+#include "pmemalloc.h"
+#include "ashmemalloc.h"
 #include "gr.h"
 #include "comptype.h"
 
 using namespace gralloc;
 using namespace qdutils;
+using android::sp;
+
+const int GRALLOC_HEAP_MASK  =  GRALLOC_USAGE_PRIVATE_ADSP_HEAP      |
+                                GRALLOC_USAGE_PRIVATE_UI_CONTIG_HEAP |
+                                GRALLOC_USAGE_PRIVATE_SMI_HEAP       |
+                                GRALLOC_USAGE_PRIVATE_SYSTEM_HEAP    |
+                                GRALLOC_USAGE_PRIVATE_IOMMU_HEAP     |
+                                GRALLOC_USAGE_PRIVATE_MM_HEAP        |
+                                GRALLOC_USAGE_PRIVATE_WRITEBACK_HEAP |
+                                GRALLOC_USAGE_PRIVATE_CAMERA_HEAP;
+
 
 //Common functions
 static bool canFallback(int usage, bool triedSystem)
@@ -75,22 +89,31 @@ static bool useUncached(int usage)
 }
 
 IAllocController* IAllocController::sController = NULL;
-IAllocController* IAllocController::getInstance(void)
+IAllocController* IAllocController::getInstance(bool useMasterHeap)
 {
     if(sController == NULL) {
+#ifdef USE_ION
         sController = new IonController();
+#else
+        if(useMasterHeap)
+            sController = new PmemAshmemController();
+        else
+            sController = new PmemKernelController();
+#endif
     }
     return sController;
 }
 
 
+#ifdef USE_ION
 //-------------- IonController-----------------------//
 IonController::IonController()
 {
     mIonAlloc = new IonAlloc();
 }
 
-int IonController::allocate(alloc_data& data, int usage)
+int IonController::allocate(alloc_data& data, int usage,
+                            int compositionType)
 {
     int ionFlags = 0;
     int ret;
@@ -113,12 +136,20 @@ int IonController::allocate(alloc_data& data, int usage)
     if(usage & GRALLOC_USAGE_PRIVATE_MM_HEAP)
         ionFlags |= ION_HEAP(ION_CP_MM_HEAP_ID);
 
+    if(usage & GRALLOC_USAGE_PRIVATE_WRITEBACK_HEAP)
+        ionFlags |= ION_HEAP(ION_CP_WB_HEAP_ID);
+
     if(usage & GRALLOC_USAGE_PRIVATE_CAMERA_HEAP)
         ionFlags |= ION_HEAP(ION_CAMERA_HEAP_ID);
 
     if(usage & GRALLOC_USAGE_PRIVATE_CP_BUFFER)
         ionFlags |= ION_SECURE;
 
+    if(usage & GRALLOC_USAGE_PRIVATE_DO_NOT_MAP)
+        data.allocType  |=  private_handle_t::PRIV_FLAGS_NOT_MAPPED;
+    else
+        data.allocType  &=  ~(private_handle_t::PRIV_FLAGS_NOT_MAPPED);
+
     // if no flags are set, default to
     // SF + IOMMU heaps, so that bypass can work
     // we can fall back to system heap if
@@ -152,7 +183,7 @@ int IonController::allocate(alloc_data& data, int usage)
 
 IMemAlloc* IonController::getAllocator(int flags)
 {
-    IMemAlloc* memalloc = NULL;
+    IMemAlloc* memalloc;
     if (flags & private_handle_t::PRIV_FLAGS_USES_ION) {
         memalloc = mIonAlloc;
     } else {
@@ -161,7 +192,151 @@ IMemAlloc* IonController::getAllocator(int flags)
 
     return memalloc;
 }
+#endif
+
+//-------------- PmemKernelController-----------------------//
+//XXX: Remove - we're not using pmem anymore
+#ifndef USE_ION
+PmemKernelController::PmemKernelController()
+{
+    mPmemAdspAlloc = new PmemKernelAlloc(DEVICE_PMEM_ADSP);
+    // XXX: Right now, there is no need to maintain an instance
+    // of the SMI allocator as we need it only in a few cases
+}
+
+PmemKernelController::~PmemKernelController()
+{
+}
+
+int PmemKernelController::allocate(alloc_data& data, int usage, int compositionType)
+{
+    int ret = 0;
+    bool adspFallback = false;
+    if (!(usage & GRALLOC_USAGE_PRIVATE_SMI_HEAP))
+        adspFallback = true;
+
+    // Try SMI first
+    if ((usage & GRALLOC_USAGE_PRIVATE_SMI_HEAP) ||
+        (usage & GRALLOC_USAGE_EXTERNAL_DISP)    ||
+        (usage & GRALLOC_USAGE_PROTECTED))
+    {
+        int tempFd = open(DEVICE_PMEM_SMIPOOL, O_RDWR, 0);
+        if(tempFd > 0) {
+            close(tempFd);
+            IMemAlloc* memalloc;
+            memalloc = new PmemKernelAlloc(DEVICE_PMEM_SMIPOOL);
+            ret = memalloc->alloc_buffer(data);
+            if(ret >= 0)
+                return ret;
+            else {
+                if(adspFallback)
+                    ALOGW("Allocation from SMI failed, trying ADSP");
+            }
+        }
+    }
+
+    if ((usage & GRALLOC_USAGE_PRIVATE_ADSP_HEAP) || adspFallback) {
+        ret = mPmemAdspAlloc->alloc_buffer(data);
+    }
+    return ret;
+}
+
+IMemAlloc* PmemKernelController::getAllocator(int flags)
+{
+    IMemAlloc* memalloc;
+    if (flags & private_handle_t::PRIV_FLAGS_USES_PMEM_ADSP)
+        memalloc = mPmemAdspAlloc;
+    else {
+        ALOGE("%s: Invalid flags passed: 0x%x", __FUNCTION__, flags);
+        memalloc = NULL;
+    }
+
+    return memalloc;
+}
+
+//-------------- PmemAshmmemController-----------------------//
+
+PmemAshmemController::PmemAshmemController()
+{
+    mPmemUserspaceAlloc = new PmemUserspaceAlloc();
+    mAshmemAlloc = new AshmemAlloc();
+    mPmemKernelCtrl = new PmemKernelController();
+}
 
+PmemAshmemController::~PmemAshmemController()
+{
+}
+
+int PmemAshmemController::allocate(alloc_data& data, int usage, int compositionType)
+{
+    int ret = 0;
+    data.allocType = 0;
+
+    // Make buffers cacheable by default
+    data.uncached = false;
+
+    // Override if we explicitly need uncached buffers
+    if (usage & GRALLOC_USAGE_PRIVATE_UNCACHED)
+        data.uncached = true;
+
+    // If ADSP or SMI is requested use the kernel controller
+    if(usage & (GRALLOC_USAGE_PRIVATE_ADSP_HEAP|
+                GRALLOC_USAGE_PRIVATE_SMI_HEAP)) {
+        ret = mPmemKernelCtrl->allocate(data, usage, compositionType);
+        if(ret < 0)
+            ALOGE("%s: Failed to allocate ADSP/SMI memory", __func__);
+        else
+            data.allocType = private_handle_t::PRIV_FLAGS_USES_PMEM_ADSP;
+        return ret;
+    }
+
+    if(usage & GRALLOC_USAGE_PRIVATE_SYSTEM_HEAP) {
+        ret = mAshmemAlloc->alloc_buffer(data);
+        if(ret >= 0) {
+            data.allocType = private_handle_t::PRIV_FLAGS_USES_ASHMEM;
+            data.allocType |= private_handle_t::PRIV_FLAGS_NONCONTIGUOUS_MEM;
+        }
+        return ret;
+    }
+
+    // if no memory specific flags are set,
+    // default to EBI heap, so that bypass
+    // can work. We can fall back to system
+    // heap if we run out.
+    ret = mPmemUserspaceAlloc->alloc_buffer(data);
+
+    // Fallback
+    if(ret >= 0 ) {
+        data.allocType = private_handle_t::PRIV_FLAGS_USES_PMEM;
+    } else if(ret < 0 && canFallback(usage, false)) {
+        ALOGW("Falling back to ashmem");
+        ret = mAshmemAlloc->alloc_buffer(data);
+        if(ret >= 0) {
+            data.allocType = private_handle_t::PRIV_FLAGS_USES_ASHMEM;
+            data.allocType |= private_handle_t::PRIV_FLAGS_NONCONTIGUOUS_MEM;
+        }
+    }
+
+    return ret;
+}
+
+IMemAlloc* PmemAshmemController::getAllocator(int flags)
+{
+    IMemAlloc* memalloc;
+    if (flags & private_handle_t::PRIV_FLAGS_USES_PMEM)
+        memalloc = mPmemUserspaceAlloc;
+    else if (flags & private_handle_t::PRIV_FLAGS_USES_PMEM_ADSP)
+        memalloc = mPmemKernelCtrl->getAllocator(flags);
+    else if (flags & private_handle_t::PRIV_FLAGS_USES_ASHMEM)
+        memalloc = mAshmemAlloc;
+    else {
+        ALOGE("%s: Invalid flags passed: 0x%x", __FUNCTION__, flags);
+        memalloc = NULL;
+    }
+
+    return memalloc;
+}
+#endif
 size_t getBufferSizeAndDimensions(int width, int height, int format,
                                   int& alignedw, int &alignedh)
 {
@@ -242,8 +417,8 @@ int alloc_buffer(private_handle_t **pHnd, int w, int h, int format, int usage)
 {
     alloc_data data;
     int alignedw, alignedh;
-    gralloc::IAllocController* sAlloc =
-        gralloc::IAllocController::getInstance();
+    IAllocController* sAlloc =
+        gralloc::IAllocController::getInstance(false);
     data.base = 0;
     data.fd = -1;
     data.offset = 0;
@@ -252,15 +427,14 @@ int alloc_buffer(private_handle_t **pHnd, int w, int h, int format, int usage)
     data.uncached = useUncached(usage);
     int allocFlags = usage;
 
-    int err = sAlloc->allocate(data, allocFlags);
+    int err = sAlloc->allocate(data, allocFlags, 0);
     if (0 != err) {
         ALOGE("%s: allocate failed", __FUNCTION__);
         return -ENOMEM;
     }
 
     private_handle_t* hnd = new private_handle_t(data.fd, data.size,
-                                                 data.allocType, 0, format,
-                                                 alignedw, alignedh);
+                                                 data.allocType, 0, format, alignedw, alignedh);
     hnd->base = (int) data.base;
     hnd->offset = data.offset;
     hnd->gpuaddr = 0;
@@ -271,7 +445,7 @@ int alloc_buffer(private_handle_t **pHnd, int w, int h, int format, int usage)
 void free_buffer(private_handle_t *hnd)
 {
     gralloc::IAllocController* sAlloc =
-        gralloc::IAllocController::getInstance();
+        gralloc::IAllocController::getInstance(false);
     if (hnd && hnd->fd > 0) {
         IMemAlloc* memalloc = sAlloc->getAllocator(hnd->flags);
         memalloc->free_buffer((void*)hnd->base, hnd->size, hnd->offset, hnd->fd);
diff --git a/libgralloc/alloc_controller.h b/libgralloc/alloc_controller.h
index f04917a..8b61155 100644
--- a/libgralloc/alloc_controller.h
+++ b/libgralloc/alloc_controller.h
@@ -29,25 +29,27 @@
 #ifndef GRALLOC_ALLOCCONTROLLER_H
 #define GRALLOC_ALLOCCONTROLLER_H
 
+#include <utils/RefBase.h>
+
 namespace gralloc {
 
 struct alloc_data;
 class IMemAlloc;
 class IonAlloc;
 
-class IAllocController {
+class IAllocController : public android::RefBase {
 
     public:
     /* Allocate using a suitable method
      * Returns the type of buffer allocated
      */
-    virtual int allocate(alloc_data& data, int usage) = 0;
+    virtual int allocate(alloc_data& data, int usage, int compositionType) = 0;
 
     virtual IMemAlloc* getAllocator(int flags) = 0;
 
     virtual ~IAllocController() {};
 
-    static IAllocController* getInstance(void);
+    static IAllocController* getInstance(bool useMasterHeap);
 
     private:
     static IAllocController* sController;
@@ -57,15 +59,55 @@ class IAllocController {
 class IonController : public IAllocController {
 
     public:
-    virtual int allocate(alloc_data& data, int usage);
+    virtual int allocate(alloc_data& data, int usage,
+                         int compositionType);
 
     virtual IMemAlloc* getAllocator(int flags);
 
     IonController();
 
     private:
-    IonAlloc* mIonAlloc;
+    IMemAlloc* mIonAlloc;
+
+};
+
+class PmemKernelController : public IAllocController {
+
+    public:
+    virtual int allocate(alloc_data& data, int usage,
+                         int compositionType);
+
+    virtual IMemAlloc* getAllocator(int flags);
+
+    PmemKernelController ();
+
+    ~PmemKernelController ();
+
+    private:
+    IMemAlloc* mPmemAdspAlloc;
 
 };
+
+// Main pmem controller - this should only
+// be used within gralloc
+class PmemAshmemController : public IAllocController {
+
+    public:
+    virtual int allocate(alloc_data& data, int usage,
+                         int compositionType);
+
+    virtual IMemAlloc* getAllocator(int flags);
+
+    PmemAshmemController();
+
+    ~PmemAshmemController();
+
+    private:
+    IMemAlloc* mPmemUserspaceAlloc;
+    IMemAlloc* mAshmemAlloc;
+    IAllocController* mPmemKernelCtrl;
+
+};
+
 } //end namespace gralloc
 #endif // GRALLOC_ALLOCCONTROLLER_H
diff --git a/libgralloc/ashmemalloc.cpp b/libgralloc/ashmemalloc.cpp
index e69de29..89b1944 100644
--- a/libgralloc/ashmemalloc.cpp
+++ b/libgralloc/ashmemalloc.cpp
@@ -0,0 +1,138 @@
+/*
+ * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Code Aurora Forum, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <stdlib.h>
+#include <cutils/log.h>
+#include <linux/ashmem.h>
+#include <cutils/ashmem.h>
+#include <errno.h>
+#include "ashmemalloc.h"
+
+using gralloc::AshmemAlloc;
+int AshmemAlloc::alloc_buffer(alloc_data& data)
+{
+    int err = 0;
+    int fd = -1;
+    void* base = 0;
+    int offset = 0;
+    char name[ASHMEM_NAME_LEN];
+    snprintf(name, ASHMEM_NAME_LEN, "gralloc-buffer-%x", data.pHandle);
+    int prot = PROT_READ | PROT_WRITE;
+    fd = ashmem_create_region(name, data.size);
+    if (fd < 0) {
+        ALOGE("couldn't create ashmem (%s)", strerror(errno));
+        err = -errno;
+    } else {
+        if (ashmem_set_prot_region(fd, prot) < 0) {
+            ALOGE("ashmem_set_prot_region(fd=%d, prot=%x) failed (%s)",
+                  fd, prot, strerror(errno));
+            close(fd);
+            err = -errno;
+        } else {
+            base = mmap(0, data.size, prot, MAP_SHARED|MAP_POPULATE|MAP_LOCKED, fd, 0);
+            if (base == MAP_FAILED) {
+                ALOGE("alloc mmap(fd=%d, size=%d, prot=%x) failed (%s)",
+                      fd, data.size, prot, strerror(errno));
+                close(fd);
+                err = -errno;
+            } else {
+                memset((char*)base + offset, 0, data.size);
+            }
+        }
+    }
+    if(err == 0) {
+        data.fd = fd;
+        data.base = base;
+        data.offset = offset;
+        clean_buffer(base, data.size, offset, fd);
+        ALOGV("ashmem: Allocated buffer base:%p size:%d fd:%d",
+              base, data.size, fd);
+
+    }
+    return err;
+
+}
+
+int AshmemAlloc::free_buffer(void* base, size_t size, int offset, int fd)
+{
+    ALOGV("ashmem: Freeing buffer base:%p size:%d fd:%d",
+          base, size, fd);
+    int err = 0;
+
+    if(!base) {
+        ALOGE("Invalid free");
+        return -EINVAL;
+    }
+    err = unmap_buffer(base, size, offset);
+    close(fd);
+    return err;
+}
+
+int AshmemAlloc::map_buffer(void **pBase, size_t size, int offset, int fd)
+{
+    int err = 0;
+    void *base = 0;
+
+    base = mmap(0, size, PROT_READ| PROT_WRITE,
+                MAP_SHARED|MAP_POPULATE, fd, 0);
+    *pBase = base;
+    if(base == MAP_FAILED) {
+        ALOGE("ashmem: Failed to map memory in the client: %s",
+              strerror(errno));
+        err = -errno;
+    } else {
+        ALOGV("ashmem: Mapped buffer base:%p size:%d fd:%d",
+              base, size, fd);
+    }
+    return err;
+}
+
+int AshmemAlloc::unmap_buffer(void *base, size_t size, int offset)
+{
+    ALOGV("ashmem: Unmapping buffer base: %p size: %d", base, size);
+    int err = munmap(base, size);
+    if(err) {
+        ALOGE("ashmem: Failed to unmap memory at %p: %s",
+              base, strerror(errno));
+    }
+    return err;
+
+}
+int AshmemAlloc::clean_buffer(void *base, size_t size, int offset, int fd)
+{
+    int err = 0;
+    if (ioctl(fd, ASHMEM_CACHE_FLUSH_RANGE, NULL)) {
+        ALOGE("ashmem: ASHMEM_CACHE_FLUSH_RANGE failed fd = %d", fd);
+    }
+
+    return err;
+}
+
diff --git a/libgralloc/ashmemalloc.h b/libgralloc/ashmemalloc.h
index e69de29..50daf04 100644
--- a/libgralloc/ashmemalloc.h
+++ b/libgralloc/ashmemalloc.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Code Aurora Forum, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef GRALLOC_ASHMEMALLOC_H
+#define GRALLOC_ASHMEMALLOC_H
+
+#include "memalloc.h"
+#include <linux/ion.h>
+
+namespace gralloc {
+class AshmemAlloc : public IMemAlloc  {
+
+    public:
+    virtual int alloc_buffer(alloc_data& data);
+
+    virtual int free_buffer(void *base, size_t size,
+                            int offset, int fd);
+
+    virtual int map_buffer(void **pBase, size_t size,
+                           int offset, int fd);
+
+    virtual int unmap_buffer(void *base, size_t size,
+                             int offset);
+
+    virtual int clean_buffer(void*base, size_t size,
+                             int offset, int fd);
+
+};
+}
+#endif /* GRALLOC_ASHMEMALLOC_H */
diff --git a/libgralloc/fb_priv.h b/libgralloc/fb_priv.h
index 8f1a09b..340968c 100644
--- a/libgralloc/fb_priv.h
+++ b/libgralloc/fb_priv.h
@@ -18,7 +18,6 @@
 #ifndef FB_PRIV_H
 #define FB_PRIV_H
 #include <linux/fb.h>
-#include <linux/msm_mdp.h>
 
 #define NUM_FRAMEBUFFERS_MIN  2
 #define NUM_FRAMEBUFFERS_MAX  3
@@ -45,8 +44,6 @@ struct private_module_t {
     pthread_mutex_t lock;
     private_handle_t *currentBuffer;
     struct fb_var_screeninfo info;
-    struct mdp_buf_fence fence;
-    struct mdp_display_commit commit;
     struct fb_fix_screeninfo finfo;
     float xdpi;
     float ydpi;
diff --git a/libgralloc/framebuffer.cpp b/libgralloc/framebuffer.cpp
index 576e021..2927eeb 100644
--- a/libgralloc/framebuffer.cpp
+++ b/libgralloc/framebuffer.cpp
@@ -100,23 +100,51 @@ static int fb_setUpdateRect(struct framebuffer_device_t* dev,
 
 static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)
 {
+    if (private_handle_t::validate(buffer) < 0)
+        return -EINVAL;
 
     fb_context_t* ctx = (fb_context_t*) dev;
 
     private_handle_t *hnd = static_cast<private_handle_t*>
-            (const_cast<native_handle_t*>(buffer));
+                            (const_cast<native_handle_t*>(buffer));
+
     private_module_t* m =
         reinterpret_cast<private_module_t*>(dev->common.module);
 
-    if (hnd && hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER) {
-        m->info.activate = FB_ACTIVATE_VBL | FB_ACTIVATE_FORCE;
-        m->info.yoffset = hnd->offset / m->finfo.line_length;
-        m->commit.var = m->info;
-        if (ioctl(m->framebuffer->fd, MSMFB_DISPLAY_COMMIT, &m->commit) == -1) {
-            ALOGE("%s: MSMFB_DISPLAY_COMMIT ioctl failed, err: %s", __FUNCTION__,
-                    strerror(errno));
+
+    if (hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER) {
+        genlock_lock_buffer(hnd, GENLOCK_READ_LOCK, GENLOCK_MAX_TIMEOUT);
+
+        const size_t offset = hnd->base - m->framebuffer->base;
+        // frame ready to be posted, signal so that hwc can update External
+        // display
+        pthread_mutex_lock(&m->fbPostLock);
+        m->currentOffset = offset;
+        m->fbPostDone = true;
+        pthread_cond_signal(&m->fbPostCond);
+        pthread_mutex_unlock(&m->fbPostLock);
+
+        m->info.activate = FB_ACTIVATE_VBL;
+        m->info.yoffset = offset / m->finfo.line_length;
+        if (ioctl(m->framebuffer->fd, FBIOPUT_VSCREENINFO, &m->info) == -1) {
+            ALOGE("FBIOPUT_VSCREENINFO failed");
+            genlock_unlock_buffer(hnd);
             return -errno;
         }
+
+        //Signals the composition thread to unblock and loop over if necessary
+        pthread_mutex_lock(&m->fbPanLock);
+        m->fbPanDone = true;
+        pthread_cond_signal(&m->fbPanCond);
+        pthread_mutex_unlock(&m->fbPanLock);
+
+        if (m->currentBuffer) {
+            genlock_unlock_buffer(m->currentBuffer);
+            m->currentBuffer = 0;
+        }
+
+        CALC_FPS();
+        m->currentBuffer = hnd;
     }
     return 0;
 }
@@ -124,8 +152,9 @@ static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)
 static int fb_compositionComplete(struct framebuffer_device_t* dev)
 {
     // TODO: Properly implement composition complete callback
+#ifdef ANCIENT_GL
     glFinish();
-
+#endif
     return 0;
 }
 
@@ -153,9 +182,6 @@ int mapFrameBufferLocked(struct private_module_t* module)
     if (fd < 0)
         return -errno;
 
-    memset(&module->fence, 0, sizeof(struct mdp_buf_fence));
-    memset(&module->commit, 0, sizeof(struct mdp_display_commit));
-
     struct fb_fix_screeninfo finfo;
     if (ioctl(fd, FBIOGET_FSCREENINFO, &finfo) == -1)
         return -errno;
@@ -183,14 +209,21 @@ int mapFrameBufferLocked(struct private_module_t* module)
         /*
          * Explicitly request RGBA_8888
          */
-        info.bits_per_pixel = 32;
+#ifdef SEMC_RGBA_8888_OFFSET
+        info.red.offset     = 0;
+        info.green.offset   = 8;
+        info.blue.offset    = 16;
+        info.transp.offset  = 24;
+#else
         info.red.offset     = 24;
-        info.red.length     = 8;
         info.green.offset   = 16;
-        info.green.length   = 8;
         info.blue.offset    = 8;
-        info.blue.length    = 8;
         info.transp.offset  = 0;
+#endif
+        info.bits_per_pixel = 32;
+        info.red.length     = 8;
+        info.green.length   = 8;
+        info.blue.length    = 8;
         info.transp.length  = 8;
 
         /* Note: the GL driver does not have a r=8 g=8 b=8 a=0 config, so if we
@@ -246,6 +279,11 @@ int mapFrameBufferLocked(struct private_module_t* module)
     info.yres_virtual = (size * numberOfBuffers) / line_length;
 
     uint32_t flags = PAGE_FLIP;
+    if (ioctl(fd, FBIOPUT_VSCREENINFO, &info) == -1) {
+        info.yres_virtual = size / line_length;
+        flags &= ~PAGE_FLIP;
+        ALOGW("FBIOPUT_VSCREENINFO failed, page flipping not supported");
+    }
 
     if (info.yres_virtual < ((size * 2) / line_length) ) {
         // we need at least 2 for page-flipping
@@ -267,7 +305,7 @@ int mapFrameBufferLocked(struct private_module_t* module)
 
     float xdpi = (info.xres * 25.4f) / info.width;
     float ydpi = (info.yres * 25.4f) / info.height;
-    //The reserved[3] field is used to store FPS by the driver.
+    //The reserved[4] field is used to store FPS by the driver.
     float fps  = info.reserved[3] & 0xFF;
 
     ALOGI("using (fd=%d)\n"
@@ -322,7 +360,7 @@ int mapFrameBufferLocked(struct private_module_t* module)
      */
 
     int err;
-    module->numBuffers = 2;
+    module->numBuffers = info.yres_virtual / info.yres;
     module->bufferMask = 0;
     //adreno needs page aligned offsets. Align the fbsize to pagesize.
     size_t fbSize = roundUpToPageSize(finfo.line_length * info.yres)*
@@ -362,9 +400,7 @@ static int fb_close(struct hw_device_t *dev)
 {
     fb_context_t* ctx = (fb_context_t*)dev;
     if (ctx) {
-        //Hack until fbdev is removed. Framework could close this causing hwc a
-        //pain.
-        //free(ctx);
+        free(ctx);
     }
     return 0;
 }
diff --git a/libgralloc/gpu.cpp b/libgralloc/gpu.cpp
index ed4394a..2db9e4a 100644
--- a/libgralloc/gpu.cpp
+++ b/libgralloc/gpu.cpp
@@ -29,6 +29,7 @@
 #include "alloc_controller.h"
 
 using namespace gralloc;
+using android::sp;
 
 gpu_context_t::gpu_context_t(const private_module_t* module,
                              IAllocController* alloc_ctrl ) :
@@ -43,6 +44,7 @@ gpu_context_t::gpu_context_t(const private_module_t* module,
     common.module  = const_cast<hw_module_t*>(&module->base.common);
     common.close   = gralloc_close;
     alloc          = gralloc_alloc;
+    allocSize      = gralloc_alloc_size;
     free           = gralloc_free;
 
 }
@@ -52,8 +54,8 @@ int gpu_context_t::gralloc_alloc_framebuffer_locked(size_t size, int usage,
 {
     private_module_t* m = reinterpret_cast<private_module_t*>(common.module);
 
-    // we don't support framebuffer allocations with graphics heap flags
-    if (usage & GRALLOC_HEAP_MASK) {
+    // we don't support allocations with both the FB and PMEM_ADSP flags
+    if (usage & GRALLOC_USAGE_PRIVATE_ADSP_HEAP) {
         return -EINVAL;
     }
 
@@ -136,8 +138,7 @@ int gpu_context_t::gralloc_alloc_buffer(size_t size, int usage,
     else
         data.align = getpagesize();
     data.pHandle = (unsigned int) pHandle;
-    err = mAllocCtrl->allocate(data, usage);
-
+    err = mAllocCtrl->allocate(data, usage, 0);
     if (usage & GRALLOC_USAGE_PRIVATE_UNSYNCHRONIZED) {
         flags |= private_handle_t::PRIV_FLAGS_UNSYNCHRONIZED;
     }
@@ -151,19 +152,6 @@ int gpu_context_t::gralloc_alloc_buffer(size_t size, int usage,
             flags |= private_handle_t::PRIV_FLAGS_EXTERNAL_CC;
         }
     }
-
-    if (usage & GRALLOC_USAGE_HW_VIDEO_ENCODER ) {
-        flags |= private_handle_t::PRIV_FLAGS_VIDEO_ENCODER;
-    }
-
-    if (usage & GRALLOC_USAGE_HW_CAMERA_WRITE) {
-        flags |= private_handle_t::PRIV_FLAGS_CAMERA_WRITE;
-    }
-
-    if (usage & GRALLOC_USAGE_HW_CAMERA_READ) {
-        flags |= private_handle_t::PRIV_FLAGS_CAMERA_READ;
-    }
-
     if (err == 0) {
         flags |= data.allocType;
         private_handle_t* hnd = new private_handle_t(data.fd, size, flags,
@@ -174,21 +162,27 @@ int gpu_context_t::gralloc_alloc_buffer(size_t size, int usage,
         hnd->base = int(data.base) + data.offset;
         *pHandle = hnd;
     }
-
     ALOGE_IF(err, "gralloc failed err=%s", strerror(-err));
     return err;
 }
 
 void gpu_context_t::getGrallocInformationFromFormat(int inputFormat,
+                                                    int *colorFormat,
                                                     int *bufferType)
 {
     *bufferType = BUFFER_TYPE_VIDEO;
+    *colorFormat = inputFormat;
 
-    if (inputFormat < 0x7) {
+    // HAL_PIXEL_FORMAT_RGB_888 is MPQ color format for VCAP videos
+    // value of RGB_888 is less than 0x7 and this format is not supported
+    // by the GPU
+    if ((inputFormat < 0x7) && (inputFormat != HAL_PIXEL_FORMAT_RGB_888)) {
         // RGB formats
+        *colorFormat = inputFormat;
         *bufferType = BUFFER_TYPE_UI;
     } else if ((inputFormat == HAL_PIXEL_FORMAT_R_8) ||
                (inputFormat == HAL_PIXEL_FORMAT_RG_88)) {
+        *colorFormat = inputFormat;
         *bufferType = BUFFER_TYPE_UI;
     }
 }
@@ -201,26 +195,13 @@ int gpu_context_t::alloc_impl(int w, int h, int format, int usage,
 
     size_t size;
     int alignedw, alignedh;
-    int grallocFormat = format;
-    int bufferType;
-
-    //If input format is HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED then based on
-    //the usage bits, gralloc assigns a format.
-    if(format == HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED) {
-        if(usage & GRALLOC_USAGE_HW_VIDEO_ENCODER)
-            grallocFormat = HAL_PIXEL_FORMAT_YCbCr_420_SP; //NV12
-        else if(usage & GRALLOC_USAGE_HW_CAMERA_READ)
-            grallocFormat = HAL_PIXEL_FORMAT_YCrCb_420_SP; //NV21
-        else if(usage & GRALLOC_USAGE_HW_CAMERA_WRITE)
-            grallocFormat = HAL_PIXEL_FORMAT_YCrCb_420_SP; //NV21
-    }
-
-    getGrallocInformationFromFormat(grallocFormat, &bufferType);
-    size = getBufferSizeAndDimensions(w, h, grallocFormat, alignedw, alignedh);
+    int colorFormat, bufferType;
+    getGrallocInformationFromFormat(format, &colorFormat, &bufferType);
+    size = getBufferSizeAndDimensions(w, h, colorFormat, alignedw, alignedh);
 
     if ((ssize_t)size <= 0)
         return -EINVAL;
-    size = (bufferSize >= size)? bufferSize : size;
+    size = (bufferSize != 0)? bufferSize : size;
 
     // All buffers marked as protected or for external
     // display need to go to overlay
@@ -230,14 +211,11 @@ int gpu_context_t::alloc_impl(int w, int h, int format, int usage,
         bufferType = BUFFER_TYPE_VIDEO;
     }
     int err;
-    private_module_t* m = reinterpret_cast<private_module_t*>(common.module);
-    uint32_t bufferMask = m->bufferMask;
-    uint32_t numBuffers = m->numBuffers;
-    if (usage & GRALLOC_USAGE_HW_FB && (bufferMask < ((1LU << numBuffers) - 1))) {
+    if (usage & GRALLOC_USAGE_HW_FB) {
         err = gralloc_alloc_framebuffer(size, usage, pHandle);
     } else {
         err = gralloc_alloc_buffer(size, usage, pHandle, bufferType,
-                                   grallocFormat, alignedw, alignedh);
+                                   format, alignedw, alignedh);
     }
 
     if (err < 0) {
diff --git a/libgralloc/gpu.h b/libgralloc/gpu.h
index 2920d5f..fb0021b 100644
--- a/libgralloc/gpu.h
+++ b/libgralloc/gpu.h
@@ -25,6 +25,7 @@
 
 #include <cutils/log.h>
 #include <cutils/ashmem.h>
+#include <utils/RefBase.h>
 
 #include "gralloc_priv.h"
 #include <fb_priv.h>
@@ -68,8 +69,9 @@ class gpu_context_t : public alloc_device_t {
     static int gralloc_close(struct hw_device_t *dev);
 
     private:
-   IAllocController* mAllocCtrl;
+    IAllocController* mAllocCtrl;
     void getGrallocInformationFromFormat(int inputFormat,
+                                         int *colorFormat,
                                          int *bufferType);
 };
 }
diff --git a/libgralloc/gralloc.cpp b/libgralloc/gralloc.cpp
index 7924ae3..950b1d6 100644
--- a/libgralloc/gralloc.cpp
+++ b/libgralloc/gralloc.cpp
@@ -23,6 +23,7 @@
 #include <sys/types.h>
 #include <sys/ioctl.h>
 #include <cutils/properties.h>
+#include <utils/RefBase.h>
 
 #include <linux/android_pmem.h>
 
@@ -32,6 +33,7 @@
 #include "alloc_controller.h"
 
 using namespace gralloc;
+using android::sp;
 
 int fb_device_open(const hw_module_t* module, const char* name,
                    hw_device_t** device);
@@ -97,10 +99,9 @@ int gralloc_device_open(const hw_module_t* module, const char* name,
 {
     int status = -EINVAL;
     if (!strcmp(name, GRALLOC_HARDWARE_GPU0)) {
-        const private_module_t* m = reinterpret_cast<const private_module_t*>(
-            module);
+	const private_module_t* m = reinterpret_cast<const private_module_t*>(module);
         gpu_context_t *dev;
-        IAllocController* alloc_ctrl = IAllocController::getInstance();
+        IAllocController* alloc_ctrl = IAllocController::getInstance(true);
         dev = new gpu_context_t(m, alloc_ctrl);
         *device = &dev->common;
         status = 0;
diff --git a/libgralloc/gralloc_priv.h b/libgralloc/gralloc_priv.h
index 59fbd30..7cdaa5f 100644
--- a/libgralloc/gralloc_priv.h
+++ b/libgralloc/gralloc_priv.h
@@ -34,22 +34,33 @@ enum {
     /* gralloc usage bits indicating the type
      * of allocation that should be used */
 
-    /* SYSTEM heap comes from kernel vmalloc,
-     * can never be uncached, is not secured*/
-    GRALLOC_USAGE_PRIVATE_SYSTEM_HEAP     =       GRALLOC_USAGE_PRIVATE_0,
+    /* ADSP heap is deprecated, use only if using pmem */
+    GRALLOC_USAGE_PRIVATE_ADSP_HEAP       =       GRALLOC_USAGE_PRIVATE_0,
     /* SF heap is used for application buffers, is not secured */
     GRALLOC_USAGE_PRIVATE_UI_CONTIG_HEAP  =       GRALLOC_USAGE_PRIVATE_1,
+    /* SMI heap is deprecated, use only if using pmem */
+    GRALLOC_USAGE_PRIVATE_SMI_HEAP        =       GRALLOC_USAGE_PRIVATE_2,
+    /* SYSTEM heap comes from kernel vmalloc,
+     * can never be uncached, is not secured*/
+    GRALLOC_USAGE_PRIVATE_SYSTEM_HEAP     =       GRALLOC_USAGE_PRIVATE_3,
     /* IOMMU heap comes from manually allocated pages,
      * can be cached/uncached, is not secured */
-    GRALLOC_USAGE_PRIVATE_IOMMU_HEAP      =       GRALLOC_USAGE_PRIVATE_2,
+    GRALLOC_USAGE_PRIVATE_IOMMU_HEAP      =       0x01000000,
     /* MM heap is a carveout heap for video, can be secured*/
-    GRALLOC_USAGE_PRIVATE_MM_HEAP         =       GRALLOC_USAGE_PRIVATE_3,
+    GRALLOC_USAGE_PRIVATE_MM_HEAP         =       0x02000000,
+    /* WRITEBACK heap is a carveout heap for writeback, can be secured*/
+    GRALLOC_USAGE_PRIVATE_WRITEBACK_HEAP  =       0x04000000,
     /* CAMERA heap is a carveout heap for camera, is not secured*/
-    GRALLOC_USAGE_PRIVATE_CAMERA_HEAP     =       0x01000000,
+    GRALLOC_USAGE_PRIVATE_CAMERA_HEAP     =       0x08000000,
 
     /* Set this for allocating uncached memory (using O_DSYNC)
      * cannot be used with noncontiguous heaps */
-    GRALLOC_USAGE_PRIVATE_UNCACHED        =       0x02000000,
+    GRALLOC_USAGE_PRIVATE_UNCACHED        =       0x00100000,
+
+    /* This flag needs to be set when using a non-contiguous heap from ION.
+     * If not set, the system heap is assumed to be coming from ashmem
+     */
+    GRALLOC_USAGE_PRIVATE_ION             =       0x00200000,
 
     /* This flag can be set to disable genlock synchronization
      * for the gralloc buffer. If this flag is set the caller
@@ -57,25 +68,28 @@ enum {
      * WARNING - flag is outside the standard PRIVATE region
      * and may need to be moved if the gralloc API changes
      */
-    GRALLOC_USAGE_PRIVATE_UNSYNCHRONIZED  =       0X04000000,
+    GRALLOC_USAGE_PRIVATE_UNSYNCHRONIZED  =       0X00400000,
+
+    /* Set this flag when you need to avoid mapping the memory in userspace */
+    GRALLOC_USAGE_PRIVATE_DO_NOT_MAP      =       0X00800000,
 
     /* Buffer content should be displayed on an external display only */
-    GRALLOC_USAGE_PRIVATE_EXTERNAL_ONLY   =       0x08000000,
+    GRALLOC_USAGE_PRIVATE_EXTERNAL_ONLY   =       0x00010000,
 
     /* Only this buffer content should be displayed on external, even if
      * other EXTERNAL_ONLY buffers are available. Used during suspend.
      */
-    GRALLOC_USAGE_PRIVATE_EXTERNAL_BLOCK  =       0x00100000,
+    GRALLOC_USAGE_PRIVATE_EXTERNAL_BLOCK  =       0x00020000,
 
     /* Close Caption displayed on an external display only */
-    GRALLOC_USAGE_PRIVATE_EXTERNAL_CC     =       0x00200000,
+    GRALLOC_USAGE_PRIVATE_EXTERNAL_CC     =       0x00040000,
 
     /* Use this flag to request content protected buffers. Please note
      * that this flag is different from the GRALLOC_USAGE_PROTECTED flag
      * which can be used for buffers that are not secured for DRM
      * but still need to be protected from screen captures
      */
-    GRALLOC_USAGE_PRIVATE_CP_BUFFER       =       0x00400000,
+    GRALLOC_USAGE_PRIVATE_CP_BUFFER       =       0x00080000,
 };
 
 enum {
@@ -84,19 +98,21 @@ enum {
     GRALLOC_MODULE_PERFORM_CREATE_HANDLE_FROM_BUFFER = 0x080000001,
 };
 
-#define GRALLOC_HEAP_MASK   (GRALLOC_USAGE_PRIVATE_UI_CONTIG_HEAP |\
-                             GRALLOC_USAGE_PRIVATE_SYSTEM_HEAP    |\
-                             GRALLOC_USAGE_PRIVATE_IOMMU_HEAP     |\
-                             GRALLOC_USAGE_PRIVATE_MM_HEAP        |\
-                             GRALLOC_USAGE_PRIVATE_CAMERA_HEAP)
 
 #define INTERLACE_MASK 0x80
 #define S3D_FORMAT_MASK 0xFF000
+#define DEVICE_PMEM "/dev/pmem"
+#define DEVICE_PMEM_ADSP "/dev/pmem_adsp"
+#define DEVICE_PMEM_SMIPOOL "/dev/pmem_smipool"
 /*****************************************************************************/
 enum {
     /* OEM specific HAL formats */
     HAL_PIXEL_FORMAT_NV12_ENCODEABLE        = 0x102,
+#ifdef QCOM_ICS_COMPAT
+    HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED     = 0x108,
+#else
     HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED     = 0x7FA30C03,
+#endif
     HAL_PIXEL_FORMAT_YCbCr_420_SP           = 0x109,
     HAL_PIXEL_FORMAT_YCrCb_420_SP_ADRENO    = 0x7FA30C01,
     HAL_PIXEL_FORMAT_YCrCb_422_SP           = 0x10B,
@@ -157,9 +173,6 @@ struct private_handle_t : public native_handle {
             PRIV_FLAGS_EXTERNAL_BLOCK     = 0x00004000,
             // Display this buffer on external as close caption
             PRIV_FLAGS_EXTERNAL_CC        = 0x00008000,
-            PRIV_FLAGS_VIDEO_ENCODER      = 0x00010000,
-            PRIV_FLAGS_CAMERA_WRITE       = 0x00020000,
-            PRIV_FLAGS_CAMERA_READ        = 0x00040000,
         };
 
         // file-descriptors
@@ -176,7 +189,7 @@ struct private_handle_t : public native_handle {
         // The gpu address mapped into the mmu.
         // If using ashmem, set to 0, they don't care
         int     gpuaddr;
-        int     pid;   // deprecated
+        int     pid;
         int     format;
         int     width;
         int     height;
@@ -193,7 +206,7 @@ struct private_handle_t : public native_handle {
             fd(fd), genlockHandle(-1), magic(sMagic),
             flags(flags), size(size), offset(0),
             bufferType(bufferType), base(0), gpuaddr(0),
-            pid(0), format(format),
+            pid(getpid()), format(format),
             width(width), height(height), genlockPrivFd(-1)
         {
             version = sizeof(native_handle);
diff --git a/libgralloc/ion_msm.h b/libgralloc/ion_msm.h
index e69de29..ae49bce 100644
--- a/libgralloc/ion_msm.h
+++ b/libgralloc/ion_msm.h
@@ -0,0 +1,836 @@
+/*
+ * include/linux/ion.h
+ *
+ * Copyright (C) 2011 Google, Inc.
+ * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_ION_H
+#define _LINUX_ION_H
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+
+struct ion_handle;
+/**
+ * enum ion_heap_types - list of all possible types of heaps
+ * @ION_HEAP_TYPE_SYSTEM:	 memory allocated via vmalloc
+ * @ION_HEAP_TYPE_SYSTEM_CONTIG: memory allocated via kmalloc
+ * @ION_HEAP_TYPE_CARVEOUT:	 memory allocated from a prereserved
+ * 				 carveout heap, allocations are physically
+ * 				 contiguous
+ * @ION_HEAP_TYPE_IOMMU: IOMMU memory
+ * @ION_HEAP_TYPE_CP:	 memory allocated from a prereserved
+ *				carveout heap, allocations are physically
+ *				contiguous. Used for content protection.
+ * @ION_HEAP_END:		helper for iterating over heaps
+ */
+enum ion_heap_type {
+	ION_HEAP_TYPE_SYSTEM,
+	ION_HEAP_TYPE_SYSTEM_CONTIG,
+	ION_HEAP_TYPE_CARVEOUT,
+	ION_HEAP_TYPE_IOMMU,
+	ION_HEAP_TYPE_CP,
+	ION_HEAP_TYPE_CUSTOM, /* must be last so device specific heaps always
+				 are at the end of this enum */
+	ION_NUM_HEAPS,
+};
+
+#define ION_HEAP_SYSTEM_MASK		(1 << ION_HEAP_TYPE_SYSTEM)
+#define ION_HEAP_SYSTEM_CONTIG_MASK	(1 << ION_HEAP_TYPE_SYSTEM_CONTIG)
+#define ION_HEAP_CARVEOUT_MASK		(1 << ION_HEAP_TYPE_CARVEOUT)
+#define ION_HEAP_CP_MASK		(1 << ION_HEAP_TYPE_CP)
+
+
+/**
+ * These are the only ids that should be used for Ion heap ids.
+ * The ids listed are the order in which allocation will be attempted
+ * if specified. Don't swap the order of heap ids unless you know what
+ * you are doing!
+ * Id's are spaced by purpose to allow new Id's to be inserted in-between (for
+ * possible fallbacks)
+ */
+
+enum ion_heap_ids {
+	INVALID_HEAP_ID = -1,
+	ION_CP_MM_HEAP_ID = 8,
+	ION_CP_MFC_HEAP_ID = 12,
+	ION_CP_WB_HEAP_ID = 16, /* 8660 only */
+	ION_CAMERA_HEAP_ID = 20, /* 8660 only */
+	ION_SF_HEAP_ID = 24,
+	ION_IOMMU_HEAP_ID = 25,
+	ION_QSECOM_HEAP_ID = 27,
+	ION_AUDIO_HEAP_ID = 28,
+
+	ION_MM_FIRMWARE_HEAP_ID = 29,
+	ION_SYSTEM_HEAP_ID = 30,
+
+	ION_HEAP_ID_RESERVED = 31 /** Bit reserved for ION_SECURE flag */
+};
+
+enum ion_fixed_position {
+	NOT_FIXED,
+	FIXED_LOW,
+	FIXED_MIDDLE,
+	FIXED_HIGH,
+};
+
+/**
+ * Flag to use when allocating to indicate that a heap is secure.
+ */
+#define ION_SECURE (1 << ION_HEAP_ID_RESERVED)
+
+/**
+ * Macro should be used with ion_heap_ids defined above.
+ */
+#define ION_HEAP(bit) (1 << (bit))
+
+#define ION_VMALLOC_HEAP_NAME	"vmalloc"
+#define ION_AUDIO_HEAP_NAME	"audio"
+#define ION_SF_HEAP_NAME	"sf"
+#define ION_MM_HEAP_NAME	"mm"
+#define ION_CAMERA_HEAP_NAME	"camera_preview"
+#define ION_IOMMU_HEAP_NAME	"iommu"
+#define ION_MFC_HEAP_NAME	"mfc"
+#define ION_WB_HEAP_NAME	"wb"
+#define ION_MM_FIRMWARE_HEAP_NAME	"mm_fw"
+#define ION_QSECOM_HEAP_NAME	"qsecom"
+#define ION_FMEM_HEAP_NAME	"fmem"
+
+#define CACHED          1
+#define UNCACHED        0
+
+#define ION_CACHE_SHIFT 0
+
+#define ION_SET_CACHE(__cache)  ((__cache) << ION_CACHE_SHIFT)
+
+#define ION_IS_CACHED(__flags)	((__flags) & (1 << ION_CACHE_SHIFT))
+
+/*
+ * This flag allows clients when mapping into the IOMMU to specify to
+ * defer un-mapping from the IOMMU until the buffer memory is freed.
+ */
+#define ION_IOMMU_UNMAP_DELAYED 1
+
+#ifdef __KERNEL__
+#include <linux/err.h>
+#include <mach/ion.h>
+struct ion_device;
+struct ion_heap;
+struct ion_mapper;
+struct ion_client;
+struct ion_buffer;
+
+/* This should be removed some day when phys_addr_t's are fully
+   plumbed in the kernel, and all instances of ion_phys_addr_t should
+   be converted to phys_addr_t.  For the time being many kernel interfaces
+   do not accept phys_addr_t's that would have to */
+#define ion_phys_addr_t unsigned long
+#define ion_virt_addr_t unsigned long
+
+/**
+ * struct ion_platform_heap - defines a heap in the given platform
+ * @type:	type of the heap from ion_heap_type enum
+ * @id:		unique identifier for heap.  When allocating (lower numbers
+ * 		will be allocated from first)
+ * @name:	used for debug purposes
+ * @base:	base address of heap in physical memory if applicable
+ * @size:	size of the heap in bytes if applicable
+ * @memory_type:Memory type used for the heap
+ * @extra_data:	Extra data specific to each heap type
+ */
+struct ion_platform_heap {
+	enum ion_heap_type type;
+	unsigned int id;
+	const char *name;
+	ion_phys_addr_t base;
+	size_t size;
+	enum ion_memory_types memory_type;
+	void *extra_data;
+};
+
+/**
+ * struct ion_cp_heap_pdata - defines a content protection heap in the given
+ * platform
+ * @permission_type:	Memory ID used to identify the memory to TZ
+ * @align:		Alignment requirement for the memory
+ * @secure_base:	Base address for securing the heap.
+ *			Note: This might be different from actual base address
+ *			of this heap in the case of a shared heap.
+ * @secure_size:	Memory size for securing the heap.
+ *			Note: This might be different from actual size
+ *			of this heap in the case of a shared heap.
+ * @reusable		Flag indicating whether this heap is reusable of not.
+ *			(see FMEM)
+ * @mem_is_fmem		Flag indicating whether this memory is coming from fmem
+ *			or not.
+ * @fixed_position	If nonzero, position in the fixed area.
+ * @virt_addr:		Virtual address used when using fmem.
+ * @request_region:	function to be called when the number of allocations
+ *			goes from 0 -> 1
+ * @release_region:	function to be called when the number of allocations
+ *			goes from 1 -> 0
+ * @setup_region:	function to be called upon ion registration
+ *
+ */
+struct ion_cp_heap_pdata {
+	enum ion_permission_type permission_type;
+	unsigned int align;
+	ion_phys_addr_t secure_base; /* Base addr used when heap is shared */
+	size_t secure_size; /* Size used for securing heap when heap is shared*/
+	int reusable;
+	int mem_is_fmem;
+	enum ion_fixed_position fixed_position;
+	ion_virt_addr_t *virt_addr;
+	int (*request_region)(void *);
+	int (*release_region)(void *);
+	void *(*setup_region)(void);
+};
+
+/**
+ * struct ion_co_heap_pdata - defines a carveout heap in the given platform
+ * @adjacent_mem_id:	Id of heap that this heap must be adjacent to.
+ * @align:		Alignment requirement for the memory
+ * @mem_is_fmem		Flag indicating whether this memory is coming from fmem
+ *			or not.
+ * @fixed_position	If nonzero, position in the fixed area.
+ * @request_region:	function to be called when the number of allocations
+ *			goes from 0 -> 1
+ * @release_region:	function to be called when the number of allocations
+ *			goes from 1 -> 0
+ * @setup_region:	function to be called upon ion registration
+ *
+ */
+struct ion_co_heap_pdata {
+	int adjacent_mem_id;
+	unsigned int align;
+	int mem_is_fmem;
+	enum ion_fixed_position fixed_position;
+	int (*request_region)(void *);
+	int (*release_region)(void *);
+	void *(*setup_region)(void);
+};
+
+/**
+ * struct ion_platform_data - array of platform heaps passed from board file
+ * @nr:    number of structures in the array
+ * @request_region: function to be called when the number of allocations goes
+ *						from 0 -> 1
+ * @release_region: function to be called when the number of allocations goes
+ *						from 1 -> 0
+ * @setup_region:   function to be called upon ion registration
+ * @heaps: array of platform_heap structions
+ *
+ * Provided by the board file in the form of platform data to a platform device.
+ */
+struct ion_platform_data {
+	int nr;
+	int (*request_region)(void *);
+	int (*release_region)(void *);
+	void *(*setup_region)(void);
+	struct ion_platform_heap heaps[];
+};
+
+#ifdef CONFIG_ION
+
+/**
+ * ion_client_create() -  allocate a client and returns it
+ * @dev:	the global ion device
+ * @heap_mask:	mask of heaps this client can allocate from
+ * @name:	used for debugging
+ */
+struct ion_client *ion_client_create(struct ion_device *dev,
+				     unsigned int heap_mask, const char *name);
+
+/**
+ *  msm_ion_client_create - allocate a client using the ion_device specified in
+ *				drivers/gpu/ion/msm/msm_ion.c
+ *
+ * heap_mask and name are the same as ion_client_create, return values
+ * are the same as ion_client_create.
+ */
+
+struct ion_client *msm_ion_client_create(unsigned int heap_mask,
+					const char *name);
+
+/**
+ * ion_client_destroy() -  free's a client and all it's handles
+ * @client:	the client
+ *
+ * Free the provided client and all it's resources including
+ * any handles it is holding.
+ */
+void ion_client_destroy(struct ion_client *client);
+
+/**
+ * ion_alloc - allocate ion memory
+ * @client:	the client
+ * @len:	size of the allocation
+ * @align:	requested allocation alignment, lots of hardware blocks have
+ *		alignment requirements of some kind
+ * @flags:	mask of heaps to allocate from, if multiple bits are set
+ *		heaps will be tried in order from lowest to highest order bit
+ *
+ * Allocate memory in one of the heaps provided in heap mask and return
+ * an opaque handle to it.
+ */
+struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
+			     size_t align, unsigned int flags);
+
+/**
+ * ion_free - free a handle
+ * @client:	the client
+ * @handle:	the handle to free
+ *
+ * Free the provided handle.
+ */
+void ion_free(struct ion_client *client, struct ion_handle *handle);
+
+/**
+ * ion_phys - returns the physical address and len of a handle
+ * @client:	the client
+ * @handle:	the handle
+ * @addr:	a pointer to put the address in
+ * @len:	a pointer to put the length in
+ *
+ * This function queries the heap for a particular handle to get the
+ * handle's physical address.  It't output is only correct if
+ * a heap returns physically contiguous memory -- in other cases
+ * this api should not be implemented -- ion_map_dma should be used
+ * instead.  Returns -EINVAL if the handle is invalid.  This has
+ * no implications on the reference counting of the handle --
+ * the returned value may not be valid if the caller is not
+ * holding a reference.
+ */
+int ion_phys(struct ion_client *client, struct ion_handle *handle,
+	     ion_phys_addr_t *addr, size_t *len);
+
+/**
+ * ion_map_kernel - create mapping for the given handle
+ * @client:	the client
+ * @handle:	handle to map
+ * @flags:	flags for this mapping
+ *
+ * Map the given handle into the kernel and return a kernel address that
+ * can be used to access this address. If no flags are specified, this
+ * will return a non-secure uncached mapping.
+ */
+void *ion_map_kernel(struct ion_client *client, struct ion_handle *handle,
+			unsigned long flags);
+
+/**
+ * ion_unmap_kernel() - destroy a kernel mapping for a handle
+ * @client:	the client
+ * @handle:	handle to unmap
+ */
+void ion_unmap_kernel(struct ion_client *client, struct ion_handle *handle);
+
+/**
+ * ion_map_dma - create a dma mapping for a given handle
+ * @client:	the client
+ * @handle:	handle to map
+ *
+ * Return an sglist describing the given handle
+ */
+struct scatterlist *ion_map_dma(struct ion_client *client,
+				struct ion_handle *handle,
+				unsigned long flags);
+
+/**
+ * ion_unmap_dma() - destroy a dma mapping for a handle
+ * @client:	the client
+ * @handle:	handle to unmap
+ */
+void ion_unmap_dma(struct ion_client *client, struct ion_handle *handle);
+
+/**
+ * ion_share() - given a handle, obtain a buffer to pass to other clients
+ * @client:	the client
+ * @handle:	the handle to share
+ *
+ * Given a handle, return a buffer, which exists in a global name
+ * space, and can be passed to other clients.  Should be passed into ion_import
+ * to obtain a new handle for this buffer.
+ *
+ * NOTE: This function does do not an extra reference.  The burden is on the
+ * caller to make sure the buffer doesn't go away while it's being passed to
+ * another client.  That is, ion_free should not be called on this handle until
+ * the buffer has been imported into the other client.
+ */
+struct ion_buffer *ion_share(struct ion_client *client,
+			     struct ion_handle *handle);
+
+/**
+ * ion_import() - given an buffer in another client, import it
+ * @client:	this blocks client
+ * @buffer:	the buffer to import (as obtained from ion_share)
+ *
+ * Given a buffer, add it to the client and return the handle to use to refer
+ * to it further.  This is called to share a handle from one kernel client to
+ * another.
+ */
+struct ion_handle *ion_import(struct ion_client *client,
+			      struct ion_buffer *buffer);
+
+/**
+ * ion_import_fd() - given an fd obtained via ION_IOC_SHARE ioctl, import it
+ * @client:	this blocks client
+ * @fd:		the fd
+ *
+ * A helper function for drivers that will be recieving ion buffers shared
+ * with them from userspace.  These buffers are represented by a file
+ * descriptor obtained as the return from the ION_IOC_SHARE ioctl.
+ * This function coverts that fd into the underlying buffer, and returns
+ * the handle to use to refer to it further.
+ */
+struct ion_handle *ion_import_fd(struct ion_client *client, int fd);
+
+/**
+ * ion_handle_get_flags - get the flags for a given handle
+ *
+ * @client - client who allocated the handle
+ * @handle - handle to get the flags
+ * @flags - pointer to store the flags
+ *
+ * Gets the current flags for a handle. These flags indicate various options
+ * of the buffer (caching, security, etc.)
+ */
+int ion_handle_get_flags(struct ion_client *client, struct ion_handle *handle,
+				unsigned long *flags);
+
+
+/**
+ * ion_map_iommu - map the given handle into an iommu
+ *
+ * @client - client who allocated the handle
+ * @handle - handle to map
+ * @domain_num - domain number to map to
+ * @partition_num - partition number to allocate iova from
+ * @align - alignment for the iova
+ * @iova_length - length of iova to map. If the iova length is
+ *		greater than the handle length, the remaining
+ *		address space will be mapped to a dummy buffer.
+ * @iova - pointer to store the iova address
+ * @buffer_size - pointer to store the size of the buffer
+ * @flags - flags for options to map
+ * @iommu_flags - flags specific to the iommu.
+ *
+ * Maps the handle into the iova space specified via domain number. Iova
+ * will be allocated from the partition specified via partition_num.
+ * Returns 0 on success, negative value on error.
+ */
+int ion_map_iommu(struct ion_client *client, struct ion_handle *handle,
+			int domain_num, int partition_num, unsigned long align,
+			unsigned long iova_length, unsigned long *iova,
+			unsigned long *buffer_size,
+			unsigned long flags, unsigned long iommu_flags);
+
+
+/**
+ * ion_handle_get_size - get the allocated size of a given handle
+ *
+ * @client - client who allocated the handle
+ * @handle - handle to get the size
+ * @size - pointer to store the size
+ *
+ * gives the allocated size of a handle. returns 0 on success, negative
+ * value on error
+ *
+ * NOTE: This is intended to be used only to get a size to pass to map_iommu.
+ * You should *NOT* rely on this for any other usage.
+ */
+
+int ion_handle_get_size(struct ion_client *client, struct ion_handle *handle,
+			unsigned long *size);
+
+/**
+ * ion_unmap_iommu - unmap the handle from an iommu
+ *
+ * @client - client who allocated the handle
+ * @handle - handle to unmap
+ * @domain_num - domain to unmap from
+ * @partition_num - partition to unmap from
+ *
+ * Decrement the reference count on the iommu mapping. If the count is
+ * 0, the mapping will be removed from the iommu.
+ */
+void ion_unmap_iommu(struct ion_client *client, struct ion_handle *handle,
+			int domain_num, int partition_num);
+
+
+/**
+ * ion_secure_heap - secure a heap
+ *
+ * @client - a client that has allocated from the heap heap_id
+ * @heap_id - heap id to secure.
+ *
+ * Secure a heap
+ * Returns 0 on success
+ */
+int ion_secure_heap(struct ion_device *dev, int heap_id);
+
+/**
+ * ion_unsecure_heap - un-secure a heap
+ *
+ * @client - a client that has allocated from the heap heap_id
+ * @heap_id - heap id to un-secure.
+ *
+ * Un-secure a heap
+ * Returns 0 on success
+ */
+int ion_unsecure_heap(struct ion_device *dev, int heap_id);
+
+/**
+ * msm_ion_secure_heap - secure a heap. Wrapper around ion_secure_heap.
+ *
+  * @heap_id - heap id to secure.
+ *
+ * Secure a heap
+ * Returns 0 on success
+ */
+int msm_ion_secure_heap(int heap_id);
+
+/**
+ * msm_ion_unsecure_heap - unsecure a heap. Wrapper around ion_unsecure_heap.
+ *
+  * @heap_id - heap id to secure.
+ *
+ * Un-secure a heap
+ * Returns 0 on success
+ */
+int msm_ion_unsecure_heap(int heap_id);
+
+/**
+ * msm_ion_do_cache_op - do cache operations.
+ *
+ * @client - pointer to ION client.
+ * @handle - pointer to buffer handle.
+ * @vaddr -  virtual address to operate on.
+ * @len - Length of data to do cache operation on.
+ * @cmd - Cache operation to perform:
+ *		ION_IOC_CLEAN_CACHES
+ *		ION_IOC_INV_CACHES
+ *		ION_IOC_CLEAN_INV_CACHES
+ *
+ * Returns 0 on success
+ */
+int msm_ion_do_cache_op(struct ion_client *client, struct ion_handle *handle,
+			void *vaddr, unsigned long len, unsigned int cmd);
+
+#else
+static inline struct ion_client *ion_client_create(struct ion_device *dev,
+				     unsigned int heap_mask, const char *name)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline struct ion_client *msm_ion_client_create(unsigned int heap_mask,
+					const char *name)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline void ion_client_destroy(struct ion_client *client) { }
+
+static inline struct ion_handle *ion_alloc(struct ion_client *client,
+			size_t len, size_t align, unsigned int flags)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline void ion_free(struct ion_client *client,
+	struct ion_handle *handle) { }
+
+
+static inline int ion_phys(struct ion_client *client,
+	struct ion_handle *handle, ion_phys_addr_t *addr, size_t *len)
+{
+	return -ENODEV;
+}
+
+static inline void *ion_map_kernel(struct ion_client *client,
+	struct ion_handle *handle, unsigned long flags)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline void ion_unmap_kernel(struct ion_client *client,
+	struct ion_handle *handle) { }
+
+static inline struct scatterlist *ion_map_dma(struct ion_client *client,
+	struct ion_handle *handle, unsigned long flags)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline void ion_unmap_dma(struct ion_client *client,
+	struct ion_handle *handle) { }
+
+static inline struct ion_buffer *ion_share(struct ion_client *client,
+	struct ion_handle *handle)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline struct ion_handle *ion_import(struct ion_client *client,
+	struct ion_buffer *buffer)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline struct ion_handle *ion_import_fd(struct ion_client *client,
+	int fd)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline int ion_handle_get_flags(struct ion_client *client,
+	struct ion_handle *handle, unsigned long *flags)
+{
+	return -ENODEV;
+}
+
+static inline int ion_map_iommu(struct ion_client *client,
+			struct ion_handle *handle, int domain_num,
+			int partition_num, unsigned long align,
+			unsigned long iova_length, unsigned long *iova,
+			unsigned long *buffer_size,
+			unsigned long flags,
+			unsigned long iommu_flags)
+{
+	return -ENODEV;
+}
+
+static inline void ion_unmap_iommu(struct ion_client *client,
+			struct ion_handle *handle, int domain_num,
+			int partition_num)
+{
+	return;
+}
+
+static inline int ion_secure_heap(struct ion_device *dev, int heap_id)
+{
+	return -ENODEV;
+
+}
+
+static inline int ion_unsecure_heap(struct ion_device *dev, int heap_id)
+{
+	return -ENODEV;
+}
+
+static inline int msm_ion_secure_heap(int heap_id)
+{
+	return -ENODEV;
+
+}
+
+static inline int msm_ion_unsecure_heap(int heap_id)
+{
+	return -ENODEV;
+}
+
+static inline int msm_ion_do_cache_op(struct ion_client *client,
+			struct ion_handle *handle, void *vaddr,
+			unsigned long len, unsigned int cmd)
+{
+	return -ENODEV;
+}
+
+#endif /* CONFIG_ION */
+#endif /* __KERNEL__ */
+
+/**
+ * DOC: Ion Userspace API
+ *
+ * create a client by opening /dev/ion
+ * most operations handled via following ioctls
+ *
+ */
+
+/**
+ * struct ion_allocation_data - metadata passed from userspace for allocations
+ * @len:	size of the allocation
+ * @align:	required alignment of the allocation
+ * @flags:	flags passed to heap
+ * @handle:	pointer that will be populated with a cookie to use to refer
+ *		to this allocation
+ *
+ * Provided by userspace as an argument to the ioctl
+ */
+struct ion_allocation_data {
+	size_t len;
+	size_t align;
+	unsigned int flags;
+	struct ion_handle *handle;
+};
+
+/**
+ * struct ion_fd_data - metadata passed to/from userspace for a handle/fd pair
+ * @handle:	a handle
+ * @fd:		a file descriptor representing that handle
+ *
+ * For ION_IOC_SHARE or ION_IOC_MAP userspace populates the handle field with
+ * the handle returned from ion alloc, and the kernel returns the file
+ * descriptor to share or map in the fd field.  For ION_IOC_IMPORT, userspace
+ * provides the file descriptor and the kernel returns the handle.
+ */
+struct ion_fd_data {
+	struct ion_handle *handle;
+	int fd;
+};
+
+/**
+ * struct ion_handle_data - a handle passed to/from the kernel
+ * @handle:	a handle
+ */
+struct ion_handle_data {
+	struct ion_handle *handle;
+};
+
+/**
+ * struct ion_custom_data - metadata passed to/from userspace for a custom ioctl
+ * @cmd:	the custom ioctl function to call
+ * @arg:	additional data to pass to the custom ioctl, typically a user
+ *		pointer to a predefined structure
+ *
+ * This works just like the regular cmd and arg fields of an ioctl.
+ */
+struct ion_custom_data {
+	unsigned int cmd;
+	unsigned long arg;
+};
+
+
+/* struct ion_flush_data - data passed to ion for flushing caches
+ *
+ * @handle:	handle with data to flush
+ * @fd:		fd to flush
+ * @vaddr:	userspace virtual address mapped with mmap
+ * @offset:	offset into the handle to flush
+ * @length:	length of handle to flush
+ *
+ * Performs cache operations on the handle. If p is the start address
+ * of the handle, p + offset through p + offset + length will have
+ * the cache operations performed
+ */
+struct ion_flush_data {
+	struct ion_handle *handle;
+	int fd;
+	void *vaddr;
+	unsigned int offset;
+	unsigned int length;
+};
+
+/* struct ion_flag_data - information about flags for this buffer
+ *
+ * @handle:	handle to get flags from
+ * @flags:	flags of this handle
+ *
+ * Takes handle as an input and outputs the flags from the handle
+ * in the flag field.
+ */
+struct ion_flag_data {
+	struct ion_handle *handle;
+	unsigned long flags;
+};
+
+#define ION_IOC_MAGIC		'I'
+
+/**
+ * DOC: ION_IOC_ALLOC - allocate memory
+ *
+ * Takes an ion_allocation_data struct and returns it with the handle field
+ * populated with the opaque handle for the allocation.
+ */
+#define ION_IOC_ALLOC		_IOWR(ION_IOC_MAGIC, 0, \
+				      struct ion_allocation_data)
+
+/**
+ * DOC: ION_IOC_FREE - free memory
+ *
+ * Takes an ion_handle_data struct and frees the handle.
+ */
+#define ION_IOC_FREE		_IOWR(ION_IOC_MAGIC, 1, struct ion_handle_data)
+
+/**
+ * DOC: ION_IOC_MAP - get a file descriptor to mmap
+ *
+ * Takes an ion_fd_data struct with the handle field populated with a valid
+ * opaque handle.  Returns the struct with the fd field set to a file
+ * descriptor open in the current address space.  This file descriptor
+ * can then be used as an argument to mmap.
+ */
+#define ION_IOC_MAP		_IOWR(ION_IOC_MAGIC, 2, struct ion_fd_data)
+
+/**
+ * DOC: ION_IOC_SHARE - creates a file descriptor to use to share an allocation
+ *
+ * Takes an ion_fd_data struct with the handle field populated with a valid
+ * opaque handle.  Returns the struct with the fd field set to a file
+ * descriptor open in the current address space.  This file descriptor
+ * can then be passed to another process.  The corresponding opaque handle can
+ * be retrieved via ION_IOC_IMPORT.
+ */
+#define ION_IOC_SHARE		_IOWR(ION_IOC_MAGIC, 4, struct ion_fd_data)
+
+/**
+ * DOC: ION_IOC_IMPORT - imports a shared file descriptor
+ *
+ * Takes an ion_fd_data struct with the fd field populated with a valid file
+ * descriptor obtained from ION_IOC_SHARE and returns the struct with the handle
+ * filed set to the corresponding opaque handle.
+ */
+#define ION_IOC_IMPORT		_IOWR(ION_IOC_MAGIC, 5, int)
+
+/**
+ * DOC: ION_IOC_CUSTOM - call architecture specific ion ioctl
+ *
+ * Takes the argument of the architecture specific ioctl to call and
+ * passes appropriate userdata for that ioctl
+ */
+#define ION_IOC_CUSTOM		_IOWR(ION_IOC_MAGIC, 6, struct ion_custom_data)
+
+
+/**
+ * DOC: ION_IOC_CLEAN_CACHES - clean the caches
+ *
+ * Clean the caches of the handle specified.
+ */
+#define ION_IOC_CLEAN_CACHES	_IOWR(ION_IOC_MAGIC, 7, \
+						struct ion_flush_data)
+/**
+ * DOC: ION_MSM_IOC_INV_CACHES - invalidate the caches
+ *
+ * Invalidate the caches of the handle specified.
+ */
+#define ION_IOC_INV_CACHES	_IOWR(ION_IOC_MAGIC, 8, \
+						struct ion_flush_data)
+/**
+ * DOC: ION_MSM_IOC_CLEAN_CACHES - clean and invalidate the caches
+ *
+ * Clean and invalidate the caches of the handle specified.
+ */
+#define ION_IOC_CLEAN_INV_CACHES	_IOWR(ION_IOC_MAGIC, 9, \
+						struct ion_flush_data)
+
+/**
+ * DOC: ION_IOC_GET_FLAGS - get the flags of the handle
+ *
+ * Gets the flags of the current handle which indicate cachability,
+ * secure state etc.
+ */
+#define ION_IOC_GET_FLAGS		_IOWR(ION_IOC_MAGIC, 10, \
+						struct ion_flag_data)
+#endif /* _LINUX_ION_H */
diff --git a/libgralloc/ionalloc.cpp b/libgralloc/ionalloc.cpp
index 8af5a96..1ebbdfd 100644
--- a/libgralloc/ionalloc.cpp
+++ b/libgralloc/ionalloc.cpp
@@ -27,7 +27,7 @@
  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#define DEBUG 0
+
 #include <linux/ioctl.h>
 #include <sys/mman.h>
 #include <stdlib.h>
@@ -118,7 +118,9 @@ int IonAlloc::alloc_buffer(alloc_data& data)
         return err;
     }
 
-    if(!(data.flags & ION_SECURE)) {
+    if(!(data.flags & ION_SECURE) &&
+       !(data.allocType & private_handle_t::PRIV_FLAGS_NOT_MAPPED)) {
+
         base = mmap(0, ionAllocData.len, PROT_READ|PROT_WRITE,
                     MAP_SHARED, fd_data.fd, 0);
         if(base == MAP_FAILED) {
@@ -126,6 +128,8 @@ int IonAlloc::alloc_buffer(alloc_data& data)
             ALOGE("%s: Failed to map the allocated memory: %s",
                   __FUNCTION__, strerror(errno));
             ioctl(mIonFd, ION_IOC_FREE, &handle_data);
+            if(ionSyncFd >= 0)
+                close(ionSyncFd);
             ionSyncFd = FD_INIT;
             return err;
         }
@@ -142,7 +146,7 @@ int IonAlloc::alloc_buffer(alloc_data& data)
     data.base = base;
     data.fd = fd_data.fd;
     ioctl(mIonFd, ION_IOC_FREE, &handle_data);
-    ALOGD_IF(DEBUG, "ion: Allocated buffer base:%p size:%d fd:%d",
+    ALOGV("ion: Allocated buffer base:%p size:%d fd:%d",
           data.base, ionAllocData.len, data.fd);
     return 0;
 }
@@ -151,7 +155,7 @@ int IonAlloc::alloc_buffer(alloc_data& data)
 int IonAlloc::free_buffer(void* base, size_t size, int offset, int fd)
 {
     Locker::Autolock _l(mLock);
-    ALOGD_IF(DEBUG, "ion: Freeing buffer base:%p size:%d fd:%d",
+    ALOGV("ion: Freeing buffer base:%p size:%d fd:%d",
           base, size, fd);
     int err = 0;
     err = open_device();
@@ -179,10 +183,10 @@ int IonAlloc::map_buffer(void **pBase, size_t size, int offset, int fd)
     *pBase = base;
     if(base == MAP_FAILED) {
         err = -errno;
-        ALOGE("ion: Failed to map memory in the client: %s",
+        ALOGD("ion: Failed to map memory in the client: %s",
               strerror(errno));
     } else {
-        ALOGD_IF(DEBUG, "ion: Mapped buffer base:%p size:%d offset:%d fd:%d",
+        ALOGV("ion: Mapped buffer base:%p size:%d offset:%d fd:%d",
               base, size, offset, fd);
     }
     return err;
@@ -190,7 +194,7 @@ int IonAlloc::map_buffer(void **pBase, size_t size, int offset, int fd)
 
 int IonAlloc::unmap_buffer(void *base, size_t size, int offset)
 {
-    ALOGD_IF(DEBUG, "ion: Unmapping buffer  base:%p size:%d", base, size);
+    ALOGV("ion: Unmapping buffer  base:%p size:%d", base, size);
     int err = 0;
     if(munmap(base, size)) {
         err = -errno;
diff --git a/libgralloc/ionalloc.h b/libgralloc/ionalloc.h
index 58a490e..083f106 100644
--- a/libgralloc/ionalloc.h
+++ b/libgralloc/ionalloc.h
@@ -30,9 +30,11 @@
 #ifndef GRALLOC_IONALLOC_H
 #define GRALLOC_IONALLOC_H
 
-#include <linux/msm_ion.h>
 #include "memalloc.h"
 #include "gr.h"
+//#include <linux/ion.h>
+//XXX: Move to bionic
+#include "ion_msm.h"
 
 namespace gralloc {
 
diff --git a/libgralloc/mapper.cpp b/libgralloc/mapper.cpp
index 3088ecc..01ecc93 100644
--- a/libgralloc/mapper.cpp
+++ b/libgralloc/mapper.cpp
@@ -44,6 +44,7 @@
 #include "memalloc.h"
 
 using namespace gralloc;
+using android::sp;
 /*****************************************************************************/
 
 // Return the type of allocator -
@@ -51,7 +52,7 @@ using namespace gralloc;
 static IMemAlloc* getAllocator(int flags)
 {
     IMemAlloc* memalloc;
-    IAllocController* alloc_ctrl = IAllocController::getInstance();
+    IAllocController* alloc_ctrl = IAllocController::getInstance(true);
     memalloc = alloc_ctrl->getAllocator(flags);
     return memalloc;
 }
@@ -129,32 +130,35 @@ int gralloc_register_buffer(gralloc_module_t const* module,
      * out-of-line
      */
 
+    // if this handle was created in this process, then we keep it as is.
     private_handle_t* hnd = (private_handle_t*)handle;
-    hnd->base = 0;
-    void *vaddr;
-    int err = gralloc_map(module, handle, &vaddr);
-    if (err) {
-        ALOGE("%s: gralloc_map failed", __FUNCTION__);
-        return err;
-    }
+    if (hnd->pid != getpid()) {
+        hnd->base = 0;
+        void *vaddr;
+        int err = gralloc_map(module, handle, &vaddr);
+        if (err) {
+            ALOGE("%s: gralloc_map failed", __FUNCTION__);
+            return err;
+        }
 
-    // Reset the genlock private fd flag in the handle
-    hnd->genlockPrivFd = -1;
+        // Reset the genlock private fd flag in the handle
+        hnd->genlockPrivFd = -1;
 
-    // Check if there is a valid lock attached to the handle.
-    if (-1 == hnd->genlockHandle) {
-        ALOGE("%s: the lock is invalid.", __FUNCTION__);
-        gralloc_unmap(module, handle);
-        hnd->base = 0;
-        return -EINVAL;
-    }
+        // Check if there is a valid lock attached to the handle.
+        if (-1 == hnd->genlockHandle) {
+            ALOGE("%s: the lock is invalid.", __FUNCTION__);
+            gralloc_unmap(module, handle);
+            hnd->base = 0;
+            return -EINVAL;
+        }
 
-    // Attach the genlock handle
-    if (GENLOCK_NO_ERROR != genlock_attach_lock((native_handle_t *)handle)) {
-        ALOGE("%s: genlock_attach_lock failed", __FUNCTION__);
-        gralloc_unmap(module, handle);
-        hnd->base = 0;
-        return -EINVAL;
+        // Attach the genlock handle
+        if (GENLOCK_NO_ERROR != genlock_attach_lock((native_handle_t *)handle)) {
+            ALOGE("%s: genlock_attach_lock failed", __FUNCTION__);
+            gralloc_unmap(module, handle);
+            hnd->base = 0;
+            return -EINVAL;
+        }
     }
     return 0;
 }
@@ -173,16 +177,19 @@ int gralloc_unregister_buffer(gralloc_module_t const* module,
 
     private_handle_t* hnd = (private_handle_t*)handle;
 
-    if (hnd->base != 0) {
-        gralloc_unmap(module, handle);
-    }
-    hnd->base = 0;
-    // Release the genlock
-    if (-1 != hnd->genlockHandle) {
-        return genlock_release_lock((native_handle_t *)handle);
-    } else {
-        ALOGE("%s: there was no genlock attached to this buffer", __FUNCTION__);
-        return -EINVAL;
+    // never unmap buffers that were created in this process
+    if (hnd->pid != getpid()) {
+        if (hnd->base != 0) {
+            gralloc_unmap(module, handle);
+        }
+        hnd->base = 0;
+        // Release the genlock
+        if (-1 != hnd->genlockHandle) {
+            return genlock_release_lock((native_handle_t *)handle);
+        } else {
+            ALOGE("%s: there was no genlock attached to this buffer", __FUNCTION__);
+            return -EINVAL;
+        }
     }
     return 0;
 }
@@ -201,7 +208,12 @@ int terminateBuffer(gralloc_module_t const* module,
                           private_handle_t::PRIV_FLAGS_USES_PMEM_ADSP |
                           private_handle_t::PRIV_FLAGS_USES_ASHMEM |
                           private_handle_t::PRIV_FLAGS_USES_ION)) {
+            if (hnd->pid != getpid()) {
+                // ... unless it's a "master" pmem buffer, that is a buffer
+                // mapped in the process it's been allocated.
+                // (see gralloc_alloc_buffer())
                 gralloc_unmap(module, hnd);
+            }
         } else {
             ALOGE("terminateBuffer: unmapping a non pmem/ashmem buffer flags = 0x%x",
                   hnd->flags);
@@ -316,7 +328,25 @@ int gralloc_perform(struct gralloc_module_t const* module,
                     private_handle_t::sNumFds, private_handle_t::sNumInts);
                 hnd->magic = private_handle_t::sMagic;
                 hnd->fd = fd;
-                hnd->flags =  private_handle_t::PRIV_FLAGS_USES_ION;
+                unsigned int contigFlags = GRALLOC_USAGE_PRIVATE_ADSP_HEAP |
+                    GRALLOC_USAGE_PRIVATE_UI_CONTIG_HEAP |
+                    GRALLOC_USAGE_PRIVATE_SMI_HEAP;
+
+                if (memoryFlags & contigFlags) {
+                    // check if the buffer is a pmem buffer
+                    pmem_region region;
+                    if (ioctl(fd, PMEM_GET_SIZE, &region) < 0)
+                        hnd->flags =  private_handle_t::PRIV_FLAGS_USES_ION;
+                    else
+                        hnd->flags =  private_handle_t::PRIV_FLAGS_USES_PMEM |
+                            private_handle_t::PRIV_FLAGS_DO_NOT_FLUSH;
+                } else {
+                    if (memoryFlags & GRALLOC_USAGE_PRIVATE_ION)
+                        hnd->flags =  private_handle_t::PRIV_FLAGS_USES_ION;
+                    else
+                        hnd->flags =  private_handle_t::PRIV_FLAGS_USES_ASHMEM;
+                }
+
                 hnd->size = size;
                 hnd->offset = offset;
                 hnd->base = intptr_t(base) + offset;
diff --git a/libgralloc/memalloc.h b/libgralloc/memalloc.h
index af509fb..349078d 100644
--- a/libgralloc/memalloc.h
+++ b/libgralloc/memalloc.h
@@ -31,6 +31,7 @@
 #define GRALLOC_MEMALLOC_H
 
 #include <stdlib.h>
+#include <utils/RefBase.h>
 
 namespace gralloc {
 
@@ -46,7 +47,7 @@ struct alloc_data {
     int            allocType;
 };
 
-class IMemAlloc {
+class IMemAlloc : public android::RefBase {
 
     public:
     // Allocate buffer - fill in the alloc_data
diff --git a/libgralloc/pmem_bestfit_alloc.cpp b/libgralloc/pmem_bestfit_alloc.cpp
index e69de29..3af4543 100644
--- a/libgralloc/pmem_bestfit_alloc.cpp
+++ b/libgralloc/pmem_bestfit_alloc.cpp
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <cutils/log.h>
+
+#include "pmem_bestfit_alloc.h"
+
+
+// align all the memory blocks on a cache-line boundary
+const int SimpleBestFitAllocator::kMemoryAlign = 32;
+
+SimpleBestFitAllocator::SimpleBestFitAllocator()
+: mHeapSize(0)
+{
+}
+
+SimpleBestFitAllocator::SimpleBestFitAllocator(size_t size)
+: mHeapSize(0)
+{
+    setSize(size);
+}
+
+SimpleBestFitAllocator::~SimpleBestFitAllocator()
+{
+    while(!mList.isEmpty()) {
+        delete mList.remove(mList.head());
+    }
+}
+
+ssize_t SimpleBestFitAllocator::setSize(size_t size)
+{
+    Locker::Autolock _l(mLock);
+    if (mHeapSize != 0) return -EINVAL;
+    size_t pagesize = getpagesize();
+    mHeapSize = ((size + pagesize-1) & ~(pagesize-1));
+    chunk_t* node = new chunk_t(0, mHeapSize / kMemoryAlign);
+    mList.insertHead(node);
+    return size;
+}
+
+size_t SimpleBestFitAllocator::size() const
+{
+    return mHeapSize;
+}
+
+ssize_t SimpleBestFitAllocator::allocate(size_t size, uint32_t flags)
+{
+    Locker::Autolock _l(mLock);
+    if (mHeapSize == 0) return -EINVAL;
+    ssize_t offset = alloc(size, flags);
+    return offset;
+}
+
+ssize_t SimpleBestFitAllocator::deallocate(size_t offset)
+{
+    Locker::Autolock _l(mLock);
+    if (mHeapSize == 0) return -EINVAL;
+    chunk_t const * const freed = dealloc(offset);
+    if (freed) {
+        return 0;
+    }
+    return -ENOENT;
+}
+
+ssize_t SimpleBestFitAllocator::alloc(size_t size, uint32_t flags)
+{
+    if (size == 0) {
+        return 0;
+    }
+    size = (size + kMemoryAlign-1) / kMemoryAlign;
+    chunk_t* free_chunk = 0;
+    chunk_t* cur = mList.head();
+
+    size_t pagesize = getpagesize();
+    while (cur) {
+        int extra = ( -cur->start & ((pagesize/kMemoryAlign)-1) ) ;
+
+        // best fit
+        if (cur->free && (cur->size >= (size+extra))) {
+            if ((!free_chunk) || (cur->size < free_chunk->size)) {
+                free_chunk = cur;
+            }
+            if (cur->size == size) {
+                break;
+            }
+        }
+        cur = cur->next;
+    }
+
+    if (free_chunk) {
+        const size_t free_size = free_chunk->size;
+        free_chunk->free = 0;
+        free_chunk->size = size;
+        if (free_size > size) {
+            int extra = ( -free_chunk->start & ((pagesize/kMemoryAlign)-1) ) ;
+            if (extra) {
+                chunk_t* split = new chunk_t(free_chunk->start, extra);
+                free_chunk->start += extra;
+                mList.insertBefore(free_chunk, split);
+            }
+
+            ALOGE_IF(((free_chunk->start*kMemoryAlign)&(pagesize-1)),
+                     "page is not aligned!!!");
+
+            const ssize_t tail_free = free_size - (size+extra);
+            if (tail_free > 0) {
+                chunk_t* split = new chunk_t(
+                    free_chunk->start + free_chunk->size, tail_free);
+                mList.insertAfter(free_chunk, split);
+            }
+        }
+        return (free_chunk->start)*kMemoryAlign;
+    }
+    // we are out of PMEM. Print pmem stats
+    // check if there is any leak or fragmentation
+
+    ALOGD (" Out of PMEM. Dumping PMEM stats for debugging");
+    ALOGD (" ------------- PRINT PMEM STATS --------------");
+
+    cur = mList.head();
+    static uint32_t node_count;
+    static uint64_t allocated, free_space;
+
+    while (cur) {
+        ALOGD (" Node %d -> Start Address : %u Size %u Free info %d", node_count++, cur->start, cur->size, cur->free);
+
+        // if cur-> free is 1 , the node is free
+        // calculate the total allocated and total free stats also
+
+        if (cur->free)
+            free_space += cur->size;
+        else
+            allocated += cur->size;
+        // read next node
+        cur = cur->next;
+    }
+//    ALOGD (" Total Allocated: %l Total Free: %l", allocated, free_space );
+
+    node_count = 0;
+    allocated = 0;
+    free_space = 0;
+    ALOGD ("----------------------------------------------");
+    return -ENOMEM;
+}
+
+SimpleBestFitAllocator::chunk_t* SimpleBestFitAllocator::dealloc(size_t start)
+{
+    start = start / kMemoryAlign;
+    chunk_t* cur = mList.head();
+    while (cur) {
+        if (cur->start == start) {
+            //ALOG_FATAL_IF(cur->free,
+              //            "block at offset 0x%08lX of size 0x%08lX already freed",
+                  //        cur->start*kMemoryAlign, cur->size*kMemoryAlign);
+
+            // merge freed blocks together
+            chunk_t* freed = cur;
+            cur->free = 1;
+            do {
+                chunk_t* const p = cur->prev;
+                chunk_t* const n = cur->next;
+                if (p && (p->free || !cur->size)) {
+                    freed = p;
+                    p->size += cur->size;
+                    mList.remove(cur);
+                    delete cur;
+                }
+                cur = n;
+            } while (cur && cur->free);
+
+            //ALOG_FATAL_IF(!freed->free,
+              //            "freed block at offset 0x%08lX of size 0x%08lX is not free!",
+                //          freed->start * kMemoryAlign, freed->size * kMemoryAlign);
+
+            return freed;
+        }
+        cur = cur->next;
+    }
+    return 0;
+}
diff --git a/libgralloc/pmem_bestfit_alloc.h b/libgralloc/pmem_bestfit_alloc.h
index e69de29..4346ec3 100644
--- a/libgralloc/pmem_bestfit_alloc.h
+++ b/libgralloc/pmem_bestfit_alloc.h
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef GRALLOC_ALLOCATOR_H_
+#define GRALLOC_ALLOCATOR_H_
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#include "gr.h"
+#include "pmemalloc.h"
+
+// ----------------------------------------------------------------------------
+
+/*
+ * A simple templatized doubly linked-list implementation
+ */
+template <typename NODE>
+class LinkedList
+{
+    NODE*  mFirst;
+    NODE*  mLast;
+
+ public:
+    LinkedList() : mFirst(0), mLast(0) { }
+    bool        isEmpty() const { return mFirst == 0; }
+    NODE const* head() const { return mFirst; }
+    NODE*       head() { return mFirst; }
+    NODE const* tail() const { return mLast; }
+    NODE*       tail() { return mLast; }
+
+    void insertAfter(NODE* node, NODE* newNode) {
+        newNode->prev = node;
+        newNode->next = node->next;
+        if (node->next == 0) mLast = newNode;
+        else                 node->next->prev = newNode;
+        node->next = newNode;
+    }
+
+    void insertBefore(NODE* node, NODE* newNode) {
+        newNode->prev = node->prev;
+        newNode->next = node;
+        if (node->prev == 0)   mFirst = newNode;
+        else                   node->prev->next = newNode;
+        node->prev = newNode;
+    }
+
+    void insertHead(NODE* newNode) {
+        if (mFirst == 0) {
+            mFirst = mLast = newNode;
+            newNode->prev = newNode->next = 0;
+        } else {
+            newNode->prev = 0;
+            newNode->next = mFirst;
+            mFirst->prev = newNode;
+            mFirst = newNode;
+        }
+    }
+
+    void insertTail(NODE* newNode) {
+        if (mLast == 0) {
+            insertHead(newNode);
+        } else {
+            newNode->prev = mLast;
+            newNode->next = 0;
+            mLast->next = newNode;
+            mLast = newNode;
+        }
+    }
+
+    NODE* remove(NODE* node) {
+        if (node->prev == 0)    mFirst = node->next;
+        else                    node->prev->next = node->next;
+        if (node->next == 0)    mLast = node->prev;
+        else                    node->next->prev = node->prev;
+        return node;
+    }
+};
+
+class SimpleBestFitAllocator : public gralloc::PmemUserspaceAlloc::Allocator
+{
+ public:
+
+  SimpleBestFitAllocator();
+  SimpleBestFitAllocator(size_t size);
+  virtual ~SimpleBestFitAllocator();
+
+  virtual ssize_t setSize(size_t size);
+
+  virtual ssize_t allocate(size_t size, uint32_t flags = 0);
+  virtual ssize_t deallocate(size_t offset);
+  virtual size_t  size() const;
+
+ private:
+  struct chunk_t {
+      chunk_t(size_t start, size_t size)
+          : start(start), size(size), free(1), prev(0), next(0) {
+          }
+      size_t              start;
+      size_t              size : 28;
+      int                 free : 4;
+      mutable chunk_t*    prev;
+      mutable chunk_t*    next;
+  };
+
+  ssize_t  alloc(size_t size, uint32_t flags);
+  chunk_t* dealloc(size_t start);
+
+  static const int    kMemoryAlign;
+  mutable Locker      mLock;
+  LinkedList<chunk_t> mList;
+  size_t              mHeapSize;
+};
+#endif /* GRALLOC_ALLOCATOR_H_ */
diff --git a/libgralloc/pmemalloc.cpp b/libgralloc/pmemalloc.cpp
index e69de29..a246594 100644
--- a/libgralloc/pmemalloc.cpp
+++ b/libgralloc/pmemalloc.cpp
@@ -0,0 +1,387 @@
+/*
+ * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Code Aurora Forum, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <stdlib.h>
+#include <cutils/log.h>
+#include <errno.h>
+#include <linux/android_pmem.h>
+#include "gralloc_priv.h"
+#include "pmemalloc.h"
+#include "pmem_bestfit_alloc.h"
+
+using namespace gralloc;
+using android::sp;
+
+// Common functions between userspace
+// and kernel allocators
+static int getPmemTotalSize(int fd, size_t* size)
+{
+    //XXX: 7x27
+    int err = 0;
+    pmem_region region;
+    if (ioctl(fd, PMEM_GET_TOTAL_SIZE, &region)) {
+        err = -errno;
+    } else {
+        *size = region.len;
+    }
+    return err;
+}
+
+static int getOpenFlags(bool uncached)
+{
+    if(uncached)
+        return O_RDWR | O_SYNC;
+    else
+        return O_RDWR;
+}
+
+static int connectPmem(int fd, int master_fd) {
+    if (ioctl(fd, PMEM_CONNECT, master_fd))
+        return -errno;
+    return 0;
+}
+
+static int mapSubRegion(int fd, int offset, size_t size) {
+    struct pmem_region sub = { offset, size };
+    if (ioctl(fd, PMEM_MAP, &sub))
+        return -errno;
+    return 0;
+}
+
+static int unmapSubRegion(int fd, int offset, size_t size) {
+    struct pmem_region sub = { offset, size };
+    if (ioctl(fd, PMEM_UNMAP, &sub))
+        return -errno;
+    return 0;
+}
+
+static int alignPmem(int fd, size_t size, int align) {
+    struct pmem_allocation allocation;
+    allocation.size = size;
+    allocation.align = align;
+    if (ioctl(fd, PMEM_ALLOCATE_ALIGNED, &allocation))
+        return -errno;
+    return 0;
+}
+
+static int cleanPmem(void *base, size_t size, int offset, int fd) {
+    struct pmem_addr pmem_addr;
+    pmem_addr.vaddr = (unsigned long) base;
+    pmem_addr.offset = offset;
+    pmem_addr.length = size;
+    if (ioctl(fd, PMEM_CLEAN_INV_CACHES, &pmem_addr))
+        return -errno;
+    return 0;
+}
+
+//-------------- PmemUserspaceAlloc-----------------------//
+PmemUserspaceAlloc::PmemUserspaceAlloc()
+{
+    mPmemDev = DEVICE_PMEM;
+    mMasterFd = FD_INIT;
+    mAllocator = new SimpleBestFitAllocator();
+    pthread_mutex_init(&mLock, NULL);
+}
+
+PmemUserspaceAlloc::~PmemUserspaceAlloc()
+{
+}
+
+int PmemUserspaceAlloc::init_pmem_area_locked()
+{
+    ALOGV("%s: Opening master pmem FD", __FUNCTION__);
+    int err = 0;
+    int fd = open(mPmemDev, O_RDWR, 0);
+    if (fd >= 0) {
+        size_t size = 0;
+        err = getPmemTotalSize(fd, &size);
+        ALOGV("%s: Total pmem size: %d", __FUNCTION__, size);
+        if (err < 0) {
+            ALOGE("%s: PMEM_GET_TOTAL_SIZE failed (%d), limp mode", mPmemDev,
+                  err);
+            size = 8<<20;   // 8 MiB
+        }
+        mAllocator->setSize(size);
+
+        void* base = mmap(0, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd,
+                          0);
+        if (base == MAP_FAILED) {
+            err = -errno;
+            ALOGE("%s: Failed to map pmem master fd: %s", mPmemDev,
+                  strerror(errno));
+            base = 0;
+            close(fd);
+            fd = -1;
+        } else {
+            mMasterFd = fd;
+            mMasterBase = base;
+        }
+    } else {
+        err = -errno;
+        ALOGE("%s: Failed to open pmem device: %s", mPmemDev,
+              strerror(errno));
+    }
+    return err;
+}
+
+int  PmemUserspaceAlloc::init_pmem_area()
+{
+    pthread_mutex_lock(&mLock);
+    int err = mMasterFd;
+    if (err == FD_INIT) {
+        // first time, try to initialize pmem
+        ALOGV("%s: Initializing pmem area", __FUNCTION__);
+        err = init_pmem_area_locked();
+        if (err) {
+            ALOGE("%s: failed to initialize pmem area", mPmemDev);
+            mMasterFd = err;
+        }
+    } else if (err < 0) {
+        // pmem couldn't be initialized, never use it
+    } else {
+        // pmem OK
+        err = 0;
+    }
+    pthread_mutex_unlock(&mLock);
+    return err;
+
+}
+
+int PmemUserspaceAlloc::alloc_buffer(alloc_data& data)
+{
+    int err = init_pmem_area();
+    if (err == 0) {
+        void* base = mMasterBase;
+        size_t size = data.size;
+        int offset = mAllocator->allocate(size);
+        if (offset < 0) {
+            // no more pmem memory
+            ALOGE("%s: No more pmem available", mPmemDev);
+            err = -ENOMEM;
+        } else {
+            int openFlags = getOpenFlags(data.uncached);
+
+            // now create the "sub-heap"
+            int fd = open(mPmemDev, openFlags, 0);
+            err = fd < 0 ? fd : 0;
+
+            // and connect to it
+            if (err == 0)
+                err = connectPmem(fd, mMasterFd);
+
+            // and make it available to the client process
+            if (err == 0)
+                err = mapSubRegion(fd, offset, size);
+
+            if (err < 0) {
+                ALOGE("%s: Failed to initialize pmem sub-heap: %d", mPmemDev,
+                      err);
+                close(fd);
+                mAllocator->deallocate(offset);
+                fd = -1;
+            } else {
+                ALOGV("%s: Allocated buffer base:%p size:%d offset:%d fd:%d",
+                      mPmemDev, base, size, offset, fd);
+                memset((char*)base + offset, 0, size);
+                //Clean cache before flushing to ensure pmem is properly flushed
+                err = clean_buffer((void*)((intptr_t) base + offset), size, offset, fd);
+                if (err < 0) {
+                    ALOGE("cleanPmem failed: (%s)", strerror(errno));
+                }
+                cacheflush(intptr_t(base) + offset, intptr_t(base) + offset + size, 0);
+                data.base = base;
+                data.offset = offset;
+                data.fd = fd;
+            }
+        }
+    }
+    return err;
+
+}
+
+int PmemUserspaceAlloc::free_buffer(void* base, size_t size, int offset, int fd)
+{
+    ALOGV("%s: Freeing buffer base:%p size:%d offset:%d fd:%d",
+          mPmemDev, base, size, offset, fd);
+    int err = 0;
+    if (fd >= 0) {
+        int err = unmapSubRegion(fd, offset, size);
+        ALOGE_IF(err<0, "PMEM_UNMAP failed (%s), fd=%d, sub.offset=%u, "
+                 "sub.size=%u", strerror(errno), fd, offset, size);
+        if (err == 0) {
+            // we can't deallocate the memory in case of UNMAP failure
+            // because it would give that process access to someone else's
+            // surfaces, which would be a security breach.
+            mAllocator->deallocate(offset);
+        }
+        close(fd);
+    }
+    return err;
+}
+
+int PmemUserspaceAlloc::map_buffer(void **pBase, size_t size, int offset, int fd)
+{
+    int err = 0;
+    size += offset;
+    void *base = mmap(0, size, PROT_READ| PROT_WRITE,
+                      MAP_SHARED, fd, 0);
+    *pBase = base;
+    if(base == MAP_FAILED) {
+        err = -errno;
+        ALOGE("%s: Failed to map buffer size:%d offset:%d fd:%d Error: %s",
+              mPmemDev, size, offset, fd, strerror(errno));
+    } else {
+        ALOGV("%s: Mapped buffer base:%p size:%d offset:%d fd:%d",
+              mPmemDev, base, size, offset, fd);
+    }
+    return err;
+
+}
+
+int PmemUserspaceAlloc::unmap_buffer(void *base, size_t size, int offset)
+{
+    int err = 0;
+    //pmem hack
+    base = (void*)(intptr_t(base) - offset);
+    size += offset;
+    ALOGV("%s: Unmapping buffer base:%p size:%d offset:%d",
+          mPmemDev , base, size, offset);
+    if (munmap(base, size) < 0) {
+        err = -errno;
+        ALOGE("%s: Failed to unmap memory at %p :%s",
+              mPmemDev, base, strerror(errno));
+
+    }
+
+    return err;
+}
+
+int PmemUserspaceAlloc::clean_buffer(void *base, size_t size, int offset, int fd)
+{
+    return cleanPmem(base, size, offset, fd);
+}
+
+
+//-------------- PmemKernelAlloc-----------------------//
+
+PmemKernelAlloc::PmemKernelAlloc(const char* pmemdev) :
+    mPmemDev(pmemdev)
+{
+}
+
+PmemKernelAlloc::~PmemKernelAlloc()
+{
+}
+
+int PmemKernelAlloc::alloc_buffer(alloc_data& data)
+{
+    int err, offset = 0;
+    int openFlags = getOpenFlags(data.uncached);
+    int size = data.size;
+
+    int fd = open(mPmemDev, openFlags, 0);
+    if (fd < 0) {
+        err = -errno;
+        ALOGE("%s: Error opening %s", __FUNCTION__, mPmemDev);
+        return err;
+    }
+
+    if (data.align == 8192) {
+        // Tile format buffers need physical alignment to 8K
+        // Default page size does not need this ioctl
+        err = alignPmem(fd, size, 8192);
+        if (err < 0) {
+            ALOGE("alignPmem failed");
+        }
+    }
+    void* base = mmap(0, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
+    if (base == MAP_FAILED) {
+        err = -errno;
+        ALOGE("%s: failed to map pmem fd: %s", mPmemDev,
+              strerror(errno));
+        close(fd);
+        return err;
+    }
+    memset(base, 0, size);
+    clean_buffer((void*)((intptr_t) base + offset), size, offset, fd);
+    data.base = base;
+    data.offset = 0;
+    data.fd = fd;
+    ALOGV("%s: Allocated buffer base:%p size:%d fd:%d",
+          mPmemDev, base, size, fd);
+    return 0;
+
+}
+
+int PmemKernelAlloc::free_buffer(void* base, size_t size, int offset, int fd)
+{
+    ALOGV("%s: Freeing buffer base:%p size:%d fd:%d",
+          mPmemDev, base, size, fd);
+
+    int err =  unmap_buffer(base, size, offset);
+    close(fd);
+    return err;
+}
+
+int PmemKernelAlloc::map_buffer(void **pBase, size_t size, int offset, int fd)
+{
+    int err = 0;
+    void *base = mmap(0, size, PROT_READ| PROT_WRITE,
+                      MAP_SHARED, fd, 0);
+    *pBase = base;
+    if(base == MAP_FAILED) {
+        err = -errno;
+        ALOGE("%s: Failed to map memory in the client: %s",
+              mPmemDev, strerror(errno));
+    } else {
+        ALOGV("%s: Mapped buffer base:%p size:%d, fd:%d",
+              mPmemDev, base, size, fd);
+    }
+    return err;
+
+}
+
+int PmemKernelAlloc::unmap_buffer(void *base, size_t size, int offset)
+{
+    int err = 0;
+    if (munmap(base, size)) {
+        err = -errno;
+        ALOGW("%s: Error unmapping memory at %p: %s",
+              mPmemDev, base, strerror(err));
+    }
+    return err;
+
+}
+int PmemKernelAlloc::clean_buffer(void *base, size_t size, int offset, int fd)
+{
+    return cleanPmem(base, size, offset, fd);
+}
+
diff --git a/libgralloc/pmemalloc.h b/libgralloc/pmemalloc.h
index e69de29..82794ec 100644
--- a/libgralloc/pmemalloc.h
+++ b/libgralloc/pmemalloc.h
@@ -0,0 +1,106 @@
+/*
+ * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Code Aurora Forum, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef GRALLOC_PMEMALLOC_H
+#define GRALLOC_PMEMALLOC_H
+
+#include <linux/ion.h>
+#include <utils/RefBase.h>
+#include "memalloc.h"
+
+namespace gralloc {
+class PmemUserspaceAlloc : public IMemAlloc  {
+
+    public:
+    class Allocator: public android::RefBase {
+        public:
+        virtual ~Allocator() {};
+        virtual ssize_t setSize(size_t size) = 0;
+        virtual size_t  size() const = 0;
+        virtual ssize_t allocate(size_t size, uint32_t flags = 0) = 0;
+        virtual ssize_t deallocate(size_t offset) = 0;
+    };
+
+    virtual int alloc_buffer(alloc_data& data);
+
+    virtual int free_buffer(void *base, size_t size,
+                            int offset, int fd);
+
+    virtual int map_buffer(void **pBase, size_t size,
+                           int offset, int fd);
+
+    virtual int unmap_buffer(void *base, size_t size,
+                             int offset);
+
+    virtual int clean_buffer(void*base, size_t size,
+                             int offset, int fd);
+
+    PmemUserspaceAlloc();
+
+    ~PmemUserspaceAlloc();
+
+    private:
+    int mMasterFd;
+    void* mMasterBase;
+    const char* mPmemDev;
+    android::sp<Allocator> mAllocator;
+    pthread_mutex_t mLock;
+    int init_pmem_area();
+    int init_pmem_area_locked();
+
+};
+
+class PmemKernelAlloc : public IMemAlloc  {
+
+    public:
+    virtual int alloc_buffer(alloc_data& data);
+
+    virtual int free_buffer(void *base, size_t size,
+                            int offset, int fd);
+
+    virtual int map_buffer(void **pBase, size_t size,
+                           int offset, int fd);
+
+    virtual int unmap_buffer(void *base, size_t size,
+                             int offset);
+
+    virtual int clean_buffer(void*base, size_t size,
+                             int offset, int fd);
+
+    PmemKernelAlloc(const char* device);
+
+    ~PmemKernelAlloc();
+    private:
+    const char* mPmemDev;
+
+
+};
+
+}
+#endif /* GRALLOC_PMEMALLOC_H */
diff --git a/libhwcomposer/Android.mk b/libhwcomposer/Android.mk
index 25946ff..50f514d 100644
--- a/libhwcomposer/Android.mk
+++ b/libhwcomposer/Android.mk
@@ -9,6 +9,10 @@ LOCAL_SHARED_LIBRARIES        := $(common_libs) libEGL liboverlay libgenlock \
                                  libexternal libqdutils libhardware_legacy \
                                  libdl libmemalloc libqservice
 
+ifeq ($(TARGET_NO_HW_VSYNC),true)
+    common_flags += -DNO_HW_VSYNC
+endif
+
 LOCAL_CFLAGS                  := $(common_flags) -DLOG_TAG=\"hwcomposer\"
 LOCAL_ADDITIONAL_DEPENDENCIES := $(common_deps)
 LOCAL_SRC_FILES               := hwc.cpp          \
diff --git a/libhwcomposer/hwc.cpp b/libhwcomposer/hwc.cpp
index a2ea3c9..8a01cde 100644
--- a/libhwcomposer/hwc.cpp
+++ b/libhwcomposer/hwc.cpp
@@ -453,7 +453,19 @@ static int hwc_device_open(const struct hw_module_t* module, const char* name,
 
         //Setup HWC methods
         dev->device.common.tag          = HARDWARE_DEVICE_TAG;
-        dev->device.common.version      = HWC_DEVICE_API_VERSION_1_1;
+#ifndef NO_HW_VSYNC
+        //XXX: This disables hardware vsync on 8x55
+        // Fix when HW vsync is available on 8x55
+        if(dev->mMDP.version == 400 || (dev->mMDP.version >= 500)) {
+#endif
+            dev->device.common.version = 0;
+            ALOGI("%s: Hardware VSYNC not supported", __FUNCTION__);
+#ifndef NO_HW_VSYNC
+        } else {
+            dev->device.common.version = HWC_DEVICE_API_VERSION_0_3;
+            ALOGI("%s: Hardware VSYNC supported", __FUNCTION__);
+        }
+#endif
         dev->device.common.module       = const_cast<hw_module_t*>(module);
         dev->device.common.close        = hwc_device_close;
         dev->device.prepare             = hwc_prepare;
diff --git a/libhwcomposer/hwc_external.cpp b/libhwcomposer/hwc_external.cpp
index e69de29..a3d32db 100644
--- a/libhwcomposer/hwc_external.cpp
+++ b/libhwcomposer/hwc_external.cpp
@@ -0,0 +1,578 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012, Code Aurora Forum. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are
+ * retained for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define DEBUG 0
+#include <ctype.h>
+#include <fcntl.h>
+#include <media/IAudioPolicyService.h>
+#include <media/AudioSystem.h>
+#include <utils/threads.h>
+#include <utils/Errors.h>
+#include <utils/Log.h>
+
+#include <linux/msm_mdp.h>
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+#include <sys/poll.h>
+#include <sys/resource.h>
+#include <cutils/properties.h>
+#include "hwc_utils.h"
+#include "hwc_external.h"
+#include "overlayUtils.h"
+
+using namespace android;
+
+namespace qhwc {
+
+static const char *extPanelName[MAX_DISPLAY_EXTERNAL_DEVICES] = {
+    HDMI_PANEL,
+    WFD_PANEL
+};
+
+ExternalDisplay::ExternalDisplay(hwc_context_t* ctx):mFd(-1),
+    mCurrentMode(-1), mExternalDisplay(0), mModeCount(0), mHwcContext(ctx)
+{
+    memset(&mVInfo, 0, sizeof(mVInfo));
+
+    //Enable HPD for HDMI
+    if(isHDMIConfigured()) {
+        writeHPDOption(1);
+    }
+}
+
+void ExternalDisplay::setEDIDMode(int resMode) {
+    ALOGD_IF(DEBUG,"resMode=%d ", resMode);
+    int extDispType;
+    {
+        Mutex::Autolock lock(mExtDispLock);
+        extDispType = mExternalDisplay;
+        setExternalDisplay(0);
+        setResolution(resMode);
+    }
+    setExternalDisplay(extDispType);
+}
+
+void ExternalDisplay::setHPDStatus(int enabled) {
+    ALOGD_IF(DEBUG,"HPD enabled=%d", enabled);
+    writeHPDOption(enabled);
+}
+
+void ExternalDisplay::setActionSafeDimension(int w, int h) {
+    ALOGD_IF(DEBUG,"ActionSafe w=%d h=%d", w, h);
+    Mutex::Autolock lock(mExtDispLock);
+    overlay::utils::ActionSafe::getInstance()->setDimension(w, h);
+    setExternalDisplay(mExternalDisplay);
+}
+
+int ExternalDisplay::getModeCount() const {
+    ALOGD_IF(DEBUG,"HPD mModeCount=%d", mModeCount);
+    Mutex::Autolock lock(mExtDispLock);
+    return mModeCount;
+}
+
+void ExternalDisplay::getEDIDModes(int *out) const {
+    Mutex::Autolock lock(mExtDispLock);
+    for(int i = 0;i < mModeCount;i++) {
+        out[i] = mEDIDModes[i];
+    }
+}
+
+int ExternalDisplay::getExternalDisplay() const {
+    Mutex::Autolock lock(mExtDispLock);
+    return mExternalDisplay;
+}
+
+ExternalDisplay::~ExternalDisplay()
+{
+    closeFrameBuffer();
+}
+
+struct disp_mode_timing_type {
+    int  video_format;
+
+    int  active_h;
+    int  active_v;
+
+    int  front_porch_h;
+    int  pulse_width_h;
+    int  back_porch_h;
+
+    int  front_porch_v;
+    int  pulse_width_v;
+    int  back_porch_v;
+
+    int  pixel_freq;
+    bool interlaced;
+
+    void set_info(struct fb_var_screeninfo &info) const;
+};
+
+void disp_mode_timing_type::set_info(struct fb_var_screeninfo &info) const
+{
+    info.reserved[0] = 0;
+    info.reserved[1] = 0;
+    info.reserved[2] = 0;
+    info.reserved[3] = video_format;
+
+    info.xoffset = 0;
+    info.yoffset = 0;
+    info.xres = active_h;
+    info.yres = active_v;
+
+    info.pixclock = pixel_freq*1000;
+    info.vmode = interlaced ? FB_VMODE_INTERLACED : FB_VMODE_NONINTERLACED;
+
+    info.right_margin = front_porch_h;
+    info.hsync_len = pulse_width_h;
+    info.left_margin = back_porch_h;
+    info.lower_margin = front_porch_v;
+    info.vsync_len = pulse_width_v;
+    info.upper_margin = back_porch_v;
+}
+
+/* Video formates supported by the HDMI Standard */
+/* Indicates the resolution, pix clock and the aspect ratio */
+#define m640x480p60_4_3         1
+#define m720x480p60_4_3         2
+#define m720x480p60_16_9        3
+#define m1280x720p60_16_9       4
+#define m1920x1080i60_16_9      5
+#define m1440x480i60_4_3        6
+#define m1440x480i60_16_9       7
+#define m1920x1080p60_16_9      16
+#define m720x576p50_4_3         17
+#define m720x576p50_16_9        18
+#define m1280x720p50_16_9       19
+#define m1440x576i50_4_3        21
+#define m1440x576i50_16_9       22
+#define m1920x1080p50_16_9      31
+#define m1920x1080p24_16_9      32
+#define m1920x1080p25_16_9      33
+#define m1920x1080p30_16_9      34
+
+static struct disp_mode_timing_type supported_video_mode_lut[] = {
+    {m640x480p60_4_3,     640,  480,  16,  96,  48, 10, 2, 33,  25200, false},
+    {m720x480p60_4_3,     720,  480,  16,  62,  60,  9, 6, 30,  27030, false},
+    {m720x480p60_16_9,    720,  480,  16,  62,  60,  9, 6, 30,  27030, false},
+    {m1280x720p60_16_9,  1280,  720, 110,  40, 220,  5, 5, 20,  74250, false},
+    {m1920x1080i60_16_9, 1920,  540,  88,  44, 148,  2, 5,  5,  74250, false},
+    {m1440x480i60_4_3,   1440,  240,  38, 124, 114,  4, 3, 15,  27000, true},
+    {m1440x480i60_16_9,  1440,  240,  38, 124, 114,  4, 3, 15,  27000, true},
+    {m1920x1080p60_16_9, 1920, 1080,  88,  44, 148,  4, 5, 36, 148500, false},
+    {m720x576p50_4_3,     720,  576,  12,  64,  68,  5, 5, 39,  27000, false},
+    {m720x576p50_16_9,    720,  576,  12,  64,  68,  5, 5, 39,  27000, false},
+    {m1280x720p50_16_9,  1280,  720, 440,  40, 220,  5, 5, 20,  74250, false},
+    {m1440x576i50_4_3,   1440,  288,  24, 126, 138,  2, 3, 19,  27000, true},
+    {m1440x576i50_16_9,  1440,  288,  24, 126, 138,  2, 3, 19,  27000, true},
+    {m1920x1080p50_16_9, 1920, 1080, 528,  44, 148,  4, 5, 36, 148500, false},
+    {m1920x1080p24_16_9, 1920, 1080, 638,  44, 148,  4, 5, 36,  74250, false},
+    {m1920x1080p25_16_9, 1920, 1080, 528,  44, 148,  4, 5, 36,  74250, false},
+    {m1920x1080p30_16_9, 1920, 1080,  88,  44, 148,  4, 5, 36,  74250, false},
+};
+
+int ExternalDisplay::parseResolution(char* edidStr, int* edidModes)
+{
+    char delim = ',';
+    int count = 0;
+    char *start, *end;
+    // EDIDs are string delimited by ','
+    // Ex: 16,4,5,3,32,34,1
+    // Parse this string to get mode(int)
+    start = (char*) edidStr;
+    end = &delim;
+    while(*end == delim) {
+        edidModes[count] = (int) strtol(start, &end, 10);
+        start = end+1;
+        count++;
+    }
+    ALOGD_IF(DEBUG, "In %s: count = %d", __FUNCTION__, count);
+    for (int i = 0; i < count; i++)
+        ALOGD_IF(DEBUG, "Mode[%d] = %d", i, edidModes[i]);
+    return count;
+}
+
+bool ExternalDisplay::readResolution()
+{
+    int hdmiEDIDFile = open(SYSFS_EDID_MODES, O_RDONLY, 0);
+    int len = -1;
+
+    if (hdmiEDIDFile < 0) {
+        ALOGE("%s: edid_modes file '%s' not found",
+                 __FUNCTION__, SYSFS_EDID_MODES);
+        return false;
+    } else {
+        len = read(hdmiEDIDFile, mEDIDs, sizeof(mEDIDs)-1);
+        ALOGD_IF(DEBUG, "%s: EDID string: %s length = %d",
+                 __FUNCTION__, mEDIDs, len);
+        if ( len <= 0) {
+            ALOGE("%s: edid_modes file empty '%s'",
+                     __FUNCTION__, SYSFS_EDID_MODES);
+        }
+        else {
+            while (len > 1 && isspace(mEDIDs[len-1]))
+                --len;
+            mEDIDs[len] = 0;
+        }
+    }
+    close(hdmiEDIDFile);
+    if(len > 0) {
+        // GEt EDID modes from the EDID strings
+        mModeCount = parseResolution(mEDIDs, mEDIDModes);
+        ALOGD_IF(DEBUG, "%s: mModeCount = %d", __FUNCTION__,
+                 mModeCount);
+    }
+
+    return (strlen(mEDIDs) > 0);
+}
+
+const char* msmFbDevicePath[2] = {  "/dev/graphics/fb1",
+                                    "/dev/graphics/fb2"};
+
+
+bool ExternalDisplay::openFrameBuffer(int fbNum)
+{
+    if (mFd == -1) {
+        ALOGD_IF(DEBUG, "In %s: opening the framebuffer device = %d",
+                                                  __FUNCTION__, fbNum);
+        mFd = open(msmFbDevicePath[fbNum-1], O_RDWR);
+        if (mFd < 0)
+            ALOGE("%s: %s not available", __FUNCTION__,
+                                                    msmFbDevicePath[fbNum-1]);
+    }
+    return (mFd > 0);
+}
+
+bool ExternalDisplay::closeFrameBuffer()
+{
+    int ret = 0;
+    if(mFd > 0) {
+        ret = close(mFd);
+        mFd = -1;
+    }
+    return (ret == 0);
+}
+
+// clears the vinfo, edid, best modes
+void ExternalDisplay::resetInfo()
+{
+    memset(&mVInfo, 0, sizeof(mVInfo));
+    memset(mEDIDs, 0, sizeof(mEDIDs));
+    memset(mEDIDModes, 0, sizeof(mEDIDModes));
+    mModeCount = 0;
+    mCurrentMode = -1;
+}
+
+int ExternalDisplay::getModeOrder(int mode)
+{
+    switch (mode) {
+        default:
+        case m1440x480i60_4_3:
+            return 1; // 480i 4:3
+        case m1440x480i60_16_9:
+            return 2; // 480i 16:9
+        case m1440x576i50_4_3:
+            return 3; // i576i 4:3
+        case m1440x576i50_16_9:
+            return 4; // 576i 16:9
+        case m640x480p60_4_3:
+            return 5; // 640x480 4:3
+        case m720x480p60_4_3:
+            return 6; // 480p 4:3
+        case m720x480p60_16_9:
+            return 7; // 480p 16:9
+        case m720x576p50_4_3:
+            return 8; // 576p 4:3
+        case m720x576p50_16_9:
+            return 9; // 576p 16:9
+        case m1920x1080i60_16_9:
+            return 10; // 1080i 16:9
+        case m1280x720p50_16_9:
+            return 11; // 720p@50Hz
+        case m1280x720p60_16_9:
+            return 12; // 720p@60Hz
+        case m1920x1080p24_16_9:
+            return 13; //1080p@24Hz
+        case m1920x1080p25_16_9:
+            return 14; //108-p@25Hz
+        case m1920x1080p30_16_9:
+            return 15; //1080p@30Hz
+        case m1920x1080p50_16_9:
+            return 16; //1080p@50Hz
+        case m1920x1080p60_16_9:
+            return 17; //1080p@60Hz
+    }
+}
+
+// Get the best mode for the current HD TV
+int ExternalDisplay::getBestMode() {
+    int bestOrder = 0;
+    int bestMode = m640x480p60_4_3;
+    Mutex::Autolock lock(mExtDispLock);
+    // for all the edid read, get the best mode
+    for(int i = 0; i < mModeCount; i++) {
+        int mode = mEDIDModes[i];
+        int order = getModeOrder(mode);
+        if (order > bestOrder) {
+            bestOrder = order;
+            bestMode = mode;
+        }
+    }
+    return bestMode;
+}
+
+inline bool ExternalDisplay::isValidMode(int ID)
+{
+    return ((ID >= m640x480p60_4_3) && (ID <= m1920x1080p30_16_9));
+}
+
+void ExternalDisplay::setResolution(int ID)
+{
+    struct fb_var_screeninfo info;
+    int ret = 0;
+    if (!openFrameBuffer(EXTERN_DISPLAY_FB1))
+        return;
+    ret = ioctl(mFd, FBIOGET_VSCREENINFO, &mVInfo);
+    if(ret < 0) {
+        ALOGD("In %s: FBIOGET_VSCREENINFO failed Err Str = %s", __FUNCTION__,
+                                                            strerror(errno));
+    }
+#ifdef FORCE_AUTO_RESOLUTION
+    ID = 0;
+#endif
+    ALOGD_IF(DEBUG, "%s: GET Info<ID=%d %dx%d (%d,%d,%d),"
+            "(%d,%d,%d) %dMHz>", __FUNCTION__,
+            mVInfo.reserved[3], mVInfo.xres, mVInfo.yres,
+            mVInfo.right_margin, mVInfo.hsync_len, mVInfo.left_margin,
+            mVInfo.lower_margin, mVInfo.vsync_len, mVInfo.upper_margin,
+            mVInfo.pixclock/1000/1000);
+    //If its a valid mode and its a new ID - update var_screeninfo
+    if ((isValidMode(ID)) && mCurrentMode != ID) {
+        const struct disp_mode_timing_type *mode =
+            &supported_video_mode_lut[0];
+        unsigned count =  sizeof(supported_video_mode_lut)/sizeof
+            (*supported_video_mode_lut);
+        for (unsigned int i = 0; i < count; ++i) {
+            const struct disp_mode_timing_type *cur =
+                &supported_video_mode_lut[i];
+            if (cur->video_format == ID)
+                mode = cur;
+        }
+        mode->set_info(mVInfo);
+        ALOGD_IF(DEBUG, "%s: SET Info<ID=%d => Info<ID=%d %dx %d"
+                 "(%d,%d,%d), (%d,%d,%d) %dMHz>", __FUNCTION__, ID,
+                 mVInfo.reserved[3], mVInfo.xres, mVInfo.yres,
+                 mVInfo.right_margin, mVInfo.hsync_len, mVInfo.left_margin,
+                 mVInfo.lower_margin, mVInfo.vsync_len, mVInfo.upper_margin,
+                 mVInfo.pixclock/1000/1000);
+        mVInfo.activate = FB_ACTIVATE_NOW | FB_ACTIVATE_ALL | FB_ACTIVATE_FORCE;
+        ret = ioctl(mFd, FBIOPUT_VSCREENINFO, &mVInfo);
+        if(ret < 0) {
+            ALOGD("In %s: FBIOPUT_VSCREENINFO failed Err Str = %s",
+                                                 __FUNCTION__, strerror(errno));
+        }
+        mCurrentMode = ID;
+    }
+}
+
+/*
+ * This function queries the msm_fb_type for fb1 and checks whether it is
+ * HDMI or not
+ *
+ * Returns:
+ *          0 -> WFD device
+ *          1 -> HDMI device
+ */
+bool ExternalDisplay::isHDMIConfigured() {
+    bool configured = false;
+    FILE *displayDeviceFP = NULL;
+    char fbType[MAX_FRAME_BUFFER_NAME_SIZE];
+    displayDeviceFP = fopen("/sys/class/graphics/fb1/msm_fb_type", "r");
+
+    if(displayDeviceFP) {
+        fread(fbType, sizeof(char), MAX_FRAME_BUFFER_NAME_SIZE, displayDeviceFP);
+
+        if(!strncmp(fbType, extPanelName[0], sizeof(extPanelName[0]))) {
+            configured  = true;
+        }
+        fclose(displayDeviceFP);
+    }
+    return configured;
+}
+
+void ExternalDisplay::processUEventOffline(const char *str) {
+    const char *s1 = str + (strlen(str)-strlen(DEVICE_NODE_FB1));
+    // check if it is for FB1
+    if(strncmp(s1,DEVICE_NODE_FB1, strlen(DEVICE_NODE_FB1))== 0) {
+        if(isHDMIConfigured()) {
+            enableHDMIVsync(EXTERN_DISPLAY_NONE);
+            closeFrameBuffer();
+            resetInfo();
+        } else {
+            closeFrameBuffer();
+        }
+    }
+    else if(strncmp(s1, DEVICE_NODE_FB2, strlen(DEVICE_NODE_FB2)) == 0) {
+        closeFrameBuffer();
+    }
+    setExternalDisplay(EXTERN_DISPLAY_NONE);
+}
+
+void ExternalDisplay::configureWFDDisplay(int fbIndex) {
+    int ret = 0;
+    if (!openFrameBuffer(fbIndex))
+        return;
+    ret = ioctl(mFd, FBIOGET_VSCREENINFO, &mVInfo);
+    if(ret < 0) {
+        ALOGD("In %s: FBIOGET_VSCREENINFO failed Err Str = %s", __FUNCTION__,
+                strerror(errno));
+    }
+    mVInfo.activate = FB_ACTIVATE_NOW | FB_ACTIVATE_ALL | FB_ACTIVATE_FORCE;
+}
+
+void ExternalDisplay::processUEventOnline(const char *str) {
+    const char *s1 = str + (strlen(str)-strlen(DEVICE_NODE_FB1));
+    // check if it is for FB1
+    if(strncmp(s1,DEVICE_NODE_FB1, strlen(DEVICE_NODE_FB1))== 0) {
+        if(isHDMIConfigured()) {
+            // HDMI connect event.
+            // Tear-down WFD if it is active.
+            if(mExternalDisplay == EXTERN_DISPLAY_FB2) {
+                closeFrameBuffer();
+                setExternalDisplay(EXTERN_DISPLAY_NONE);
+            }
+            readResolution();
+            //Get the best mode and set
+            setResolution(getBestMode());
+            enableHDMIVsync(EXTERN_DISPLAY_FB1);
+        } else {
+            configureWFDDisplay(EXTERN_DISPLAY_FB1);
+        }
+        setExternalDisplay(EXTERN_DISPLAY_FB1);
+    }
+    else if(strncmp(s1, DEVICE_NODE_FB2, strlen(DEVICE_NODE_FB2)) == 0) {
+        // WFD connect event
+        if(mExternalDisplay  == EXTERN_DISPLAY_FB1) {
+            // HDMI has higher priority.
+            // Do Not Override.
+        }else {
+            // WFD is connected
+            configureWFDDisplay(EXTERN_DISPLAY_FB2);
+            setExternalDisplay(EXTERN_DISPLAY_FB2);
+        }
+    }
+}
+
+void ExternalDisplay::setExternalDisplay(int connected)
+{
+    hwc_context_t* ctx = mHwcContext;
+    if(ctx) {
+        ALOGD_IF(DEBUG, "%s: status = %d", __FUNCTION__,
+                 connected);
+        // Store the external display
+        mExternalDisplay = connected;
+        ALOGD_IF(DEBUG, "In %s: mExternalDisplay = %d", __FUNCTION__,
+                                                         mExternalDisplay);
+        const char* prop = (connected) ? "1" : "0";
+        // set system property
+        property_set("hw.hdmiON", prop);
+        //Invalidate
+        hwc_procs* proc = (hwc_procs*)ctx->device.reserved_proc[0];
+        if(!proc) {
+            ALOGE("%s: HWC proc not registered", __FUNCTION__);
+        } else {
+            /* Trigger redraw */
+            ALOGD_IF(DEBUG, "%s: Invalidate !!", __FUNCTION__);
+            proc->invalidate(proc);
+        }
+    }
+    return;
+}
+
+bool ExternalDisplay::writeHPDOption(int userOption) const
+{
+    bool ret = true;
+    int hdmiHPDFile = open(SYSFS_HPD,O_RDWR, 0);
+    if (hdmiHPDFile < 0) {
+        ALOGE("%s: state file '%s' not found : ret%d"
+                           "err str: %s",  __FUNCTION__, SYSFS_HPD, hdmiHPDFile,
+                           strerror(errno));
+        ret = false;
+    } else {
+        int err = -1;
+        ALOGD_IF(DEBUG, "%s: option = %d", __FUNCTION__,
+                 userOption);
+        if(userOption)
+            err = write(hdmiHPDFile, "1", 2);
+        else
+            err = write(hdmiHPDFile, "0" , 2);
+        if (err <= 0) {
+            ALOGE("%s: file write failed '%s'",
+                     __FUNCTION__, SYSFS_HPD);
+            ret = false;
+        }
+        close(hdmiHPDFile);
+    }
+    return ret;
+}
+
+/*
+ * commits the changes to the external display
+ * mExternalDisplay has the mixer number(1-> HDMI 2-> WFD)
+ */
+bool ExternalDisplay::commit()
+{
+    if(mFd == -1) {
+        return false;
+#ifdef MSMFB_OVERLAY_COMMIT
+    } else if(ioctl(mFd, MSMFB_OVERLAY_COMMIT, &mExternalDisplay) == -1) {
+         ALOGE("%s: MSMFB_OVERLAY_COMMIT failed errno: %d , str: %s",
+                                       __FUNCTION__, errno, strerror(errno));
+#else
+    } else if(ioctl(mFd, FBIOPUT_VSCREENINFO, &mVInfo) == -1) {
+         ALOGE("%s: FBIOPUT_VSCREENINFO failed, str: %s", __FUNCTION__,
+                                      strerror(errno));
+#endif
+         return false;
+    }
+    return true;
+}
+
+/*
+ * return 0 on success
+ * return -errno on ioctl failure as the hwc_eventControl need
+ * to return -errno.
+ */
+int ExternalDisplay::enableHDMIVsync(int enable)
+{
+    int ret = 0;
+#ifndef NO_HW_VSYNC
+    if(mFd > 0) {
+        int ret = ioctl(mFd, MSMFB_OVERLAY_VSYNC_CTRL, &enable);
+        if (ret<0) {
+            ALOGE("%s: enabling HDMI vsync failed, str: %s", __FUNCTION__,
+                                                            strerror(errno));
+            ret = -errno;
+        }
+    }
+#endif
+    return ret;
+}
+
+};
diff --git a/libhwcomposer/hwc_external.h b/libhwcomposer/hwc_external.h
index e69de29..6a3feee 100644
--- a/libhwcomposer/hwc_external.h
+++ b/libhwcomposer/hwc_external.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012, Code Aurora Forum. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are
+ * retained for attribution purposes only.
+
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HWC_EXTERNAL_DISPLAY_H
+#define HWC_EXTERNAL_DISPLAY_H
+
+#include <utils/threads.h>
+#include <linux/fb.h>
+
+struct hwc_context_t;
+
+namespace qhwc {
+
+#define DEVICE_ROOT "/sys/devices/virtual/graphics"
+#define DEVICE_NODE_FB1                 "fb1"
+#define DEVICE_NODE_FB2                 "fb2"
+#define HDMI_PANEL                      "dtv panel"
+#define WFD_PANEL                       "writeback panel"
+#define EXTERN_DISPLAY_NONE             0
+#define EXTERN_DISPLAY_FB1              1
+#define EXTERN_DISPLAY_FB2              2
+#define MAX_FRAME_BUFFER_NAME_SIZE      80
+#define MAX_DISPLAY_EXTERNAL_DEVICES    2
+#define HPD_ENABLE                      1
+#define HPD_DISABLE                     0
+#define DEVICE_ONLINE                   true
+#define DEVICE_OFFLINE                  false
+
+
+#define SYSFS_EDID_MODES        DEVICE_ROOT "/" DEVICE_NODE_FB1 "/edid_modes"
+#define SYSFS_HPD               DEVICE_ROOT "/" DEVICE_NODE_FB1 "/hpd"
+
+class ExternalDisplay
+{
+    //Type of external display -  OFF, HDMI, WFD
+    enum external_display_type {
+        EXT_TYPE_NONE,
+        EXT_TYPE_HDMI,
+        EXT_TYPE_WIFI
+    };
+
+    // Mirroring state
+    enum external_mirroring_state {
+        EXT_MIRRORING_OFF,
+        EXT_MIRRORING_ON,
+    };
+    public:
+    ExternalDisplay(hwc_context_t* ctx);
+    ~ExternalDisplay();
+    int getModeCount() const;
+    void getEDIDModes(int *out) const;
+    int getExternalDisplay() const;
+    void setExternalDisplay(int connected);
+    bool commit();
+    int enableHDMIVsync(int enable);
+    void setHPDStatus(int enabled);
+    void setEDIDMode(int resMode);
+    void setActionSafeDimension(int w, int h);
+    void processUEventOnline(const char *str);
+    void processUEventOffline(const char *str);
+    bool isHDMIConfigured();
+
+    private:
+    bool readResolution();
+    int parseResolution(char* edidStr, int* edidModes);
+    void setResolution(int ID);
+    bool openFrameBuffer(int fbNum);
+    bool closeFrameBuffer();
+    bool writeHPDOption(int userOption) const;
+    bool isValidMode(int ID);
+    void handleUEvent(char* str, int len);
+    int getModeOrder(int mode);
+    int getBestMode();
+    void resetInfo();
+    void configureWFDDisplay(int fbIndex);
+
+    mutable android::Mutex mExtDispLock;
+    int mFd;
+    int mCurrentMode;
+    int mExternalDisplay;
+    int mResolutionMode;
+    char mEDIDs[128];
+    int mEDIDModes[64];
+    int mModeCount;
+    hwc_context_t *mHwcContext;
+    fb_var_screeninfo mVInfo;
+};
+
+}; //qhwc
+// ---------------------------------------------------------------------------
+#endif //HWC_EXTERNAL_DISPLAY_H
diff --git a/libhwcomposer/hwc_pip.cpp b/libhwcomposer/hwc_pip.cpp
index e69de29..295e07b 100644
--- a/libhwcomposer/hwc_pip.cpp
+++ b/libhwcomposer/hwc_pip.cpp
@@ -0,0 +1,327 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012, Code Aurora Forum. All rights reserved.
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define VIDEOPIP_DEBUG 0
+#include <overlay.h>
+#include "hwc_qbuf.h"
+#include "hwc_external.h"
+#include "hwc_pip.h"
+
+namespace qhwc {
+
+//Static Members
+ovutils::eOverlayState VideoPIP::sState = ovutils::OV_CLOSED;
+int VideoPIP::sYuvCount = 0;
+int VideoPIP::sYuvLayerIndex = -1;
+bool VideoPIP::sIsYuvLayerSkip = false;
+int VideoPIP::sPIPLayerIndex = -1;
+bool VideoPIP::sIsModeOn = false;
+
+//Cache stats, figure out the state, config overlay
+bool VideoPIP::prepare(hwc_context_t *ctx, hwc_layer_list_t *list) {
+    sIsModeOn = false;
+    if(!ctx->mMDP.hasOverlay) {
+       ALOGD_IF(VIDEOPIP_DEBUG,"%s, this hw doesnt support overlay", __FUNCTION__);
+       return false;
+    }
+    if(sYuvLayerIndex == -1 || sPIPLayerIndex == -1) {
+        return false;
+    }
+    chooseState(ctx);
+    //if the state chosen above is CLOSED, skip this block.
+    if(sState != ovutils::OV_CLOSED) {
+        hwc_layer_t *yuvLayer = &list->hwLayers[sYuvLayerIndex];
+        hwc_layer_t *pipLayer = NULL;
+
+        if(sPIPLayerIndex != -1) {
+           pipLayer = &list->hwLayers[sPIPLayerIndex];
+        }
+        if(configure(ctx, yuvLayer, pipLayer)) {
+            markFlags(&list->hwLayers[sYuvLayerIndex]);
+            if(sPIPLayerIndex != -1) {
+                //Mark PIP layer as HWC_OVERLAY
+                markFlags(&list->hwLayers[sPIPLayerIndex]);
+            }
+            sIsModeOn = true;
+        }
+    }
+
+    ALOGD_IF(VIDEOPIP_DEBUG, "%s: stats: yuvCount = %d, yuvIndex = %d,"
+            "IsYuvLayerSkip = %d, pipLayerIndex = %d, IsModeOn = %d",
+            __FUNCTION__, sYuvCount, sYuvLayerIndex,
+            sIsYuvLayerSkip, sPIPLayerIndex, sIsModeOn);
+
+    return sIsModeOn;
+}
+
+void VideoPIP::chooseState(hwc_context_t *ctx) {
+    ALOGD_IF(VIDEOPIP_DEBUG, "%s: old state = %s", __FUNCTION__,
+            ovutils::getStateString(sState));
+
+    ovutils::eOverlayState newState = ovutils::OV_CLOSED;
+
+    //Support 1 video layer
+    if(sYuvCount == 2 && !ctx->mExtDisplay->getExternalDisplay()) {
+        /* PIP: Picture in picture
+           If HDMI is not connected as secondary and there are two videos
+           we can use two VG pipes for video playback. */
+        newState = ovutils::OV_2D_PIP_VIDEO_ON_PANEL;
+    }
+    sState = newState;
+    ALOGD_IF(VIDEOPIP_DEBUG, "%s: new chosen state = %s", __FUNCTION__,
+            ovutils::getStateString(sState));
+}
+
+void VideoPIP::markFlags(hwc_layer_t *layer) {
+    switch(sState) {
+        case ovutils::OV_2D_PIP_VIDEO_ON_PANEL:
+            layer->compositionType = HWC_OVERLAY;
+            break;
+        default:
+            break;
+    }
+}
+
+/* Helpers */
+bool configPrimaryVideo(hwc_context_t *ctx, hwc_layer_t *layer) {
+    overlay::Overlay& ov = *(ctx->mOverlay);
+    private_handle_t *hnd = (private_handle_t *)layer->handle;
+    ovutils::Whf info(hnd->width, hnd->height, hnd->format, hnd->size);
+
+    ovutils::eMdpFlags mdpFlags = ovutils::OV_MDP_FLAGS_NONE;
+    if (hnd->flags & private_handle_t::PRIV_FLAGS_SECURE_BUFFER) {
+        ovutils::setMdpFlags(mdpFlags,
+                ovutils::OV_MDP_SECURE_OVERLAY_SESSION);
+    }
+
+    ovutils::eIsFg isFgFlag = ovutils::IS_FG_OFF;
+    if (ctx->numHwLayers == 1) {
+        isFgFlag = ovutils::IS_FG_SET;
+    }
+
+    ovutils::PipeArgs parg(mdpFlags,
+            info,
+            ovutils::ZORDER_0,
+            isFgFlag,
+            ovutils::ROT_FLAGS_NONE);
+    ovutils::PipeArgs pargs[ovutils::MAX_PIPES] = { parg, parg, parg };
+    ov.setSource(pargs, ovutils::OV_PIPE0);
+
+    hwc_rect_t sourceCrop = layer->sourceCrop;
+    // x,y,w,h
+    ovutils::Dim dcrop(sourceCrop.left, sourceCrop.top,
+            sourceCrop.right - sourceCrop.left,
+            sourceCrop.bottom - sourceCrop.top);
+
+    ovutils::Dim dpos;
+    hwc_rect_t displayFrame = layer->displayFrame;
+    dpos.x = displayFrame.left;
+    dpos.y = displayFrame.top;
+    dpos.w = (displayFrame.right - displayFrame.left);
+    dpos.h = (displayFrame.bottom - displayFrame.top);
+
+    //Calculate the rect for primary based on whether the supplied position
+    //is within or outside bounds.
+    const int fbWidth =
+            ovutils::FrameBufferInfo::getInstance()->getWidth();
+    const int fbHeight =
+            ovutils::FrameBufferInfo::getInstance()->getHeight();
+
+    if( displayFrame.left < 0 ||
+            displayFrame.top < 0 ||
+            displayFrame.right > fbWidth ||
+            displayFrame.bottom > fbHeight) {
+
+        calculate_crop_rects(sourceCrop, displayFrame, fbWidth, fbHeight);
+
+        //Update calculated width and height
+        dcrop.w = sourceCrop.right - sourceCrop.left;
+        dcrop.h = sourceCrop.bottom - sourceCrop.top;
+
+        dpos.x = displayFrame.left;
+        dpos.y = displayFrame.top;
+        dpos.w = displayFrame.right - displayFrame.left;
+        dpos.h = displayFrame.bottom - displayFrame.top;
+    }
+
+    //Only for Primary
+    ov.setCrop(dcrop, ovutils::OV_PIPE0);
+
+    ovutils::eTransform orient =
+            static_cast<ovutils::eTransform>(layer->transform);
+    ov.setTransform(orient, ovutils::OV_PIPE0);
+
+    ov.setPosition(dpos, ovutils::OV_PIPE0);
+
+    if (!ov.commit(ovutils::OV_PIPE0)) {
+        ALOGE("%s: commit fails", __FUNCTION__);
+        return false;
+    }
+    return true;
+}
+
+
+// Configure the second video in pip scenario
+bool configPIPVideo(hwc_context_t *ctx, hwc_layer_t *layer) {
+    overlay::Overlay& ov = *(ctx->mOverlay);
+    private_handle_t *hnd = (private_handle_t *)layer->handle;
+    ovutils::Whf info(hnd->width, hnd->height, hnd->format, hnd->size);
+
+    ovutils::eMdpFlags mdpFlags = ovutils::OV_MDP_FLAGS_NONE;
+    if (hnd->flags & private_handle_t::PRIV_FLAGS_SECURE_BUFFER) {
+        ovutils::setMdpFlags(mdpFlags,
+                ovutils::OV_MDP_SECURE_OVERLAY_SESSION);
+    }
+
+    ovutils::eIsFg isFgFlag = ovutils::IS_FG_OFF;
+
+    //Set z-order 1 since this video is on top of the
+    //primary video
+    ovutils::PipeArgs parg(mdpFlags,
+            info,
+            ovutils::ZORDER_1,
+            isFgFlag,
+            ovutils::ROT_DOWNSCALE_ENABLED);
+    ovutils::PipeArgs pargs[ovutils::MAX_PIPES] = { parg, parg, parg };
+
+    // Use pipe 1, pipe 0 is used for primary video
+    ov.setSource(pargs, ovutils::OV_PIPE1);
+
+    hwc_rect_t sourceCrop = layer->sourceCrop;
+    // x,y,w,h
+    ovutils::Dim dcrop(sourceCrop.left, sourceCrop.top,
+            sourceCrop.right - sourceCrop.left,
+            sourceCrop.bottom - sourceCrop.top);
+
+    ovutils::Dim dpos;
+    hwc_rect_t displayFrame = layer->displayFrame;
+    dpos.x = displayFrame.left;
+    dpos.y = displayFrame.top;
+    dpos.w = (displayFrame.right - displayFrame.left);
+    dpos.h = (displayFrame.bottom - displayFrame.top);
+
+    //Calculate the rect for primary based on whether the supplied position
+    //is within or outside bounds.
+    const int fbWidth =
+            ovutils::FrameBufferInfo::getInstance()->getWidth();
+    const int fbHeight =
+            ovutils::FrameBufferInfo::getInstance()->getHeight();
+
+    if( displayFrame.left < 0 ||
+            displayFrame.top < 0 ||
+            displayFrame.right > fbWidth ||
+            displayFrame.bottom > fbHeight) {
+
+        calculate_crop_rects(sourceCrop, displayFrame, fbWidth, fbHeight);
+
+        //Update calculated width and height
+        dcrop.w = sourceCrop.right - sourceCrop.left;
+        dcrop.h = sourceCrop.bottom - sourceCrop.top;
+
+        dpos.x = displayFrame.left;
+        dpos.y = displayFrame.top;
+        dpos.w = displayFrame.right - displayFrame.left;
+        dpos.h = displayFrame.bottom - displayFrame.top;
+    }
+
+    //Only for Primary
+    ov.setCrop(dcrop, ovutils::OV_PIPE1);
+
+    ovutils::eTransform orient =
+            static_cast<ovutils::eTransform>(layer->transform);
+    ov.setTransform(orient, ovutils::OV_PIPE1);
+
+    ov.setPosition(dpos, ovutils::OV_PIPE1);
+
+    if (!ov.commit(ovutils::OV_PIPE1)) {
+        ALOGE("%s: commit fails", __FUNCTION__);
+        return false;
+    }
+    return true;
+}
+
+bool VideoPIP::configure(hwc_context_t *ctx, hwc_layer_t *yuvLayer,
+        hwc_layer_t *pipLayer) {
+
+    bool ret = true;
+    if (LIKELY(ctx->mOverlay)) {
+        overlay::Overlay& ov = *(ctx->mOverlay);
+        // Set overlay state
+        ov.setState(sState);
+        switch(sState) {
+            case ovutils::OV_2D_PIP_VIDEO_ON_PANEL:
+                //Configure the primary or background video
+                ret &= configPrimaryVideo(ctx, yuvLayer);
+                //Configure the PIP video
+                ret &= configPIPVideo(ctx, pipLayer);
+                break;
+            default:
+                return false;
+        }
+    } else {
+        //Ov null
+        return false;
+    }
+    return ret;
+}
+
+bool VideoPIP::draw(hwc_context_t *ctx, hwc_layer_list_t *list)
+{
+    if(!sIsModeOn || sYuvLayerIndex == -1 || sPIPLayerIndex == -1) {
+        return true;
+    }
+
+    private_handle_t *hnd = (private_handle_t *)
+            list->hwLayers[sYuvLayerIndex].handle;
+    // Lock this buffer for read.
+    ctx->qbuf->lockAndAdd(hnd);
+
+    private_handle_t *piphnd = NULL;
+    piphnd = (private_handle_t *)list->hwLayers[sPIPLayerIndex].handle;
+        ctx->qbuf->lockAndAdd(piphnd);
+
+    bool ret = true;
+    overlay::Overlay& ov = *(ctx->mOverlay);
+    ovutils::eOverlayState state = ov.getState();
+
+    switch (state) {
+        case ovutils::OV_2D_PIP_VIDEO_ON_PANEL:
+            // Play first video (background)
+            if (!ov.queueBuffer(hnd->fd, hnd->offset, ovutils::OV_PIPE0)) {
+                ALOGE("%s: queueBuffer failed for primary video", __FUNCTION__);
+                ret = false;
+            }
+            //Play pip video
+            if (piphnd && !ov.queueBuffer(piphnd->fd, piphnd->offset,
+                        ovutils::OV_PIPE1)) {
+                ALOGE("%s: queueBuffer failed for pip video", __FUNCTION__);
+                ret = false;
+            }
+            break;
+
+        default:
+            ALOGE("%s Unused state %s", __FUNCTION__,
+                    ovutils::getStateString(state));
+            break;
+    }
+
+    return ret;
+}
+
+}; //namespace qhwc
diff --git a/libhwcomposer/hwc_pip.h b/libhwcomposer/hwc_pip.h
index e69de29..6a5f39e 100644
--- a/libhwcomposer/hwc_pip.h
+++ b/libhwcomposer/hwc_pip.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012, Code Aurora Forum. All rights reserved.
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef HWC_PIP_H
+#define HWC_PIP_H
+#include "hwc_utils.h"
+
+#define LIKELY( exp )       (__builtin_expect( (exp) != 0, true  ))
+#define UNLIKELY( exp )     (__builtin_expect( (exp) != 0, false ))
+
+namespace qhwc {
+//Feature for using overlay to display videos.
+class VideoPIP {
+public:
+    //Sets up members and prepares overlay if conditions are met
+    static bool prepare(hwc_context_t *ctx, hwc_layer_list_t *list);
+    //Draws layer if this feature is on
+    static bool draw(hwc_context_t *ctx, hwc_layer_list_t *list);
+    //Receives data from hwc
+    static void setStats(int yuvCount, int yuvLayerIndex, bool isYuvLayerSkip,
+            int pipLayerIndex);
+    //resets values
+    static void reset();
+private:
+    //Choose an appropriate overlay state based on conditions
+    static void chooseState(hwc_context_t *ctx);
+    //Configures overlay for video prim and ext
+    static bool configure(hwc_context_t *ctx, hwc_layer_t *yuvlayer,
+            hwc_layer_t *pipLayer);
+    //Marks layer flags if this feature is used
+    static void markFlags(hwc_layer_t *layer);
+    //returns yuv count
+    static int getYuvCount();
+
+    //The chosen overlay state.
+    static ovutils::eOverlayState sState;
+    //Number of yuv layers in this drawing round
+    static int sYuvCount;
+    //Index of YUV layer, relevant only if count is 1
+    static int sYuvLayerIndex;
+    //Flags if a yuv layer is animating or below something that is animating
+    static bool sIsYuvLayerSkip;
+    //Holds the PIP layer index in case of two videos, -1 by default
+    static int sPIPLayerIndex;
+    //Flags if this feature is on.
+    static bool sIsModeOn;
+};
+
+inline void VideoPIP::setStats(int yuvCount, int yuvLayerIndex,
+        bool isYuvLayerSkip, int pipLayerIndex) {
+    sYuvCount = yuvCount;
+    sYuvLayerIndex = yuvLayerIndex;
+    sIsYuvLayerSkip = isYuvLayerSkip;
+    sPIPLayerIndex = pipLayerIndex;
+}
+
+inline int VideoPIP::getYuvCount() { return sYuvCount; }
+inline void VideoPIP::reset() {
+    sYuvCount = 0;
+    sYuvLayerIndex = -1;
+    sIsYuvLayerSkip = false;
+    sPIPLayerIndex = -1;
+    sIsModeOn = false;
+    sState = ovutils::OV_CLOSED;
+}
+}; //namespace qhwc
+
+#endif //HWC_PIP_H
diff --git a/libhwcomposer/hwc_service.cpp b/libhwcomposer/hwc_service.cpp
index e69de29..d0e29df 100644
--- a/libhwcomposer/hwc_service.cpp
+++ b/libhwcomposer/hwc_service.cpp
@@ -0,0 +1,190 @@
+/*
+ *  Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of Code Aurora Forum, Inc. nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <hwc_service.h>
+#include <hwc_utils.h>
+
+#define HWC_SERVICE_DEBUG 0
+
+using namespace android;
+
+namespace hwcService {
+
+HWComposerService* HWComposerService::sHwcService = NULL;
+// ----------------------------------------------------------------------------
+HWComposerService::HWComposerService():mHwcContext(0)
+{
+    ALOGD_IF(HWC_SERVICE_DEBUG, "HWComposerService Constructor invoked");
+}
+
+HWComposerService::~HWComposerService()
+{
+    ALOGD_IF(HWC_SERVICE_DEBUG,"HWComposerService Destructor invoked");
+}
+
+status_t HWComposerService::setHPDStatus(int hpdStatus) {
+    ALOGD_IF(HWC_SERVICE_DEBUG, "hpdStatus=%d", hpdStatus);
+    qhwc::ExternalDisplay *externalDisplay = mHwcContext->mExtDisplay;
+    externalDisplay->setHPDStatus(hpdStatus);
+    return NO_ERROR;
+}
+
+status_t HWComposerService::setResolutionMode(int resMode) {
+    ALOGD_IF(HWC_SERVICE_DEBUG, "resMode=%d", resMode);
+    qhwc::ExternalDisplay *externalDisplay = mHwcContext->mExtDisplay;
+    if(externalDisplay->getExternalDisplay()) {
+        externalDisplay->setEDIDMode(resMode);
+    } else {
+        ALOGE("External Display not connected");
+    }
+    return NO_ERROR;
+}
+
+status_t HWComposerService::setActionSafeDimension(int w, int h) {
+    ALOGD_IF(HWC_SERVICE_DEBUG, "w=%d h=%d", w, h);
+    qhwc::ExternalDisplay *externalDisplay = mHwcContext->mExtDisplay;
+    if((w > MAX_ACTIONSAFE_WIDTH) && (h > MAX_ACTIONSAFE_HEIGHT)) {
+        ALOGE_IF(HWC_SERVICE_DEBUG,
+            "ActionSafe Width and Height exceeded the limit! w=%d h=%d", w, h);
+        return NO_ERROR;
+    }
+    if(externalDisplay->getExternalDisplay()) {
+        externalDisplay->setActionSafeDimension(w, h);
+    } else {
+        ALOGE("External Display not connected");
+    }
+    return NO_ERROR;
+}
+status_t HWComposerService::setOpenSecureStart( ) {
+    mHwcContext->mSecureConfig = true;
+    //Invalidate
+    hwc_procs* proc = (hwc_procs*)mHwcContext->device.reserved_proc[0];
+    if(!proc) {
+        ALOGE("%s: HWC proc not registered", __FUNCTION__);
+    } else {
+        /* Trigger redraw */
+        ALOGD_IF(HWC_SERVICE_DEBUG, "%s: Invalidate !!", __FUNCTION__);
+        proc->invalidate(proc);
+    }
+    return NO_ERROR;
+}
+
+status_t HWComposerService::setOpenSecureEnd( ) {
+    mHwcContext->mSecure = true;
+    mHwcContext->mSecureConfig = false;
+    //Invalidate
+    hwc_procs* proc = (hwc_procs*)mHwcContext->device.reserved_proc[0];
+    if(!proc) {
+        ALOGE("%s: HWC proc not registered", __FUNCTION__);
+    } else {
+        /* Trigger redraw */
+        ALOGD_IF(HWC_SERVICE_DEBUG, "%s: Invalidate !!", __FUNCTION__);
+        proc->invalidate(proc);
+    }
+    return NO_ERROR;
+}
+
+status_t HWComposerService::setCloseSecureStart( ) {
+    mHwcContext->mSecureConfig = true;
+    //Invalidate
+    hwc_procs* proc = (hwc_procs*)mHwcContext->device.reserved_proc[0];
+    if(!proc) {
+        ALOGE("%s: HWC proc not registered", __FUNCTION__);
+    } else {
+        /* Trigger redraw */
+        ALOGD_IF(HWC_SERVICE_DEBUG, "%s: Invalidate !!", __FUNCTION__);
+        proc->invalidate(proc);
+    }
+    return NO_ERROR;
+}
+
+status_t HWComposerService::setCloseSecureEnd( ) {
+    mHwcContext->mSecure = false;
+    mHwcContext->mSecureConfig = false;
+    //Invalidate
+    hwc_procs* proc = (hwc_procs*)mHwcContext->device.reserved_proc[0];
+    if(!proc) {
+        ALOGE("%s: HWC proc not registered", __FUNCTION__);
+    } else {
+        /* Trigger redraw */
+        ALOGD_IF(HWC_SERVICE_DEBUG, "%s: Invalidate !!", __FUNCTION__);
+        proc->invalidate(proc);
+    }
+    return NO_ERROR;
+}
+
+status_t HWComposerService::getResolutionModeCount(int *resModeCount) {
+    qhwc::ExternalDisplay *externalDisplay = mHwcContext->mExtDisplay;
+     if(externalDisplay->getExternalDisplay()) {
+        *resModeCount = externalDisplay->getModeCount();
+    } else {
+        ALOGE("External Display not connected");
+    }
+    ALOGD_IF(HWC_SERVICE_DEBUG, "resModeCount=%d", *resModeCount);
+    return NO_ERROR;
+}
+
+status_t HWComposerService::getResolutionModes(int *resModes, int count) {
+    qhwc::ExternalDisplay *externalDisplay = mHwcContext->mExtDisplay;
+    if(externalDisplay->getExternalDisplay()) {
+        externalDisplay->getEDIDModes(resModes);
+    } else {
+        ALOGE("External Display not connected");
+    }
+    return NO_ERROR;
+}
+
+status_t HWComposerService::getExternalDisplay(int *dispType) {
+    qhwc::ExternalDisplay *externalDisplay = mHwcContext->mExtDisplay;
+    *dispType = externalDisplay->getExternalDisplay();
+    ALOGD_IF(HWC_SERVICE_DEBUG, "dispType=%d", *dispType);
+    return NO_ERROR;
+}
+
+HWComposerService* HWComposerService::getInstance()
+{
+    if(!sHwcService) {
+        sHwcService = new HWComposerService();
+        sp<IServiceManager> sm = defaultServiceManager();
+        sm->addService(String16("display.hwcservice"), sHwcService);
+        if(sm->checkService(String16("display.hwcservice")) != NULL)
+            ALOGD_IF(HWC_SERVICE_DEBUG, "adding display.hwcservice succeeded");
+        else
+            ALOGD_IF(HWC_SERVICE_DEBUG, "adding display.hwcservice failed");
+    }
+    return sHwcService;
+}
+
+void HWComposerService::setHwcContext(hwc_context_t *hwcCtx) {
+    ALOGD_IF(HWC_SERVICE_DEBUG, "hwcCtx=0x%x", (int)hwcCtx);
+    if(hwcCtx) {
+        mHwcContext = hwcCtx;
+    }
+}
+}
diff --git a/libhwcomposer/hwc_service.h b/libhwcomposer/hwc_service.h
index e69de29..63b06c1 100644
--- a/libhwcomposer/hwc_service.h
+++ b/libhwcomposer/hwc_service.h
@@ -0,0 +1,75 @@
+/*
+ *  Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of Code Aurora Forum, Inc. nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef ANDROID_HWCOMPOSER_SERVICE_H
+#define ANDROID_HWCOMPOSER_SERVICE_H
+
+#include <utils/Errors.h>
+#include <sys/types.h>
+#include <cutils/log.h>
+#include <binder/IServiceManager.h>
+#include <ihwc.h>
+#include <hwc_external.h>
+
+
+namespace hwcService {
+// ----------------------------------------------------------------------------
+
+class HWComposerService : public BnHWComposer {
+enum {
+    MAX_ACTIONSAFE_WIDTH  = 10,
+    MAX_ACTIONSAFE_HEIGHT = MAX_ACTIONSAFE_WIDTH,
+};
+private:
+    HWComposerService();
+public:
+    ~HWComposerService();
+
+    static HWComposerService* getInstance();
+    virtual android::status_t getResolutionModeCount(int *modeCount);
+    virtual android::status_t getResolutionModes(int *EDIDModes, int count = 1);
+    virtual android::status_t getExternalDisplay(int *extDisp);
+
+    virtual android::status_t setHPDStatus(int enable);
+    virtual android::status_t setResolutionMode(int resMode);
+    virtual android::status_t setActionSafeDimension(int w, int h);
+
+    // Secure Intent Hooks
+    virtual android::status_t setOpenSecureStart();
+    virtual android::status_t setOpenSecureEnd();
+    virtual android::status_t setCloseSecureStart();
+    virtual android::status_t setCloseSecureEnd();
+    void setHwcContext(hwc_context_t *hwcCtx);
+private:
+    static HWComposerService *sHwcService;
+    hwc_context_t *mHwcContext;
+};
+
+}; // namespace hwcService
+#endif // ANDROID_HWCOMPOSER_SERVICE_H
diff --git a/libhwcomposer/hwc_utils.cpp b/libhwcomposer/hwc_utils.cpp
index 41a9c5a..6a57c9d 100644
--- a/libhwcomposer/hwc_utils.cpp
+++ b/libhwcomposer/hwc_utils.cpp
@@ -51,7 +51,6 @@ static void openFramebufferDevice(hwc_context_t *ctx)
 void initContext(hwc_context_t *ctx)
 {
     openFramebufferDevice(ctx);
-    overlay::Overlay::initOverlay();
     for(uint32_t i = 0; i < HWC_NUM_DISPLAY_TYPES; i++) {
         ctx->mOverlay[i] = overlay::Overlay::getInstance(i);
     }
diff --git a/libhwcomposer/hwc_vsync.cpp b/libhwcomposer/hwc_vsync.cpp
index d461a8b..61ad0cb 100644
--- a/libhwcomposer/hwc_vsync.cpp
+++ b/libhwcomposer/hwc_vsync.cpp
@@ -70,68 +70,29 @@ static void *vsync_loop(void *param)
                strerror(errno));
         return NULL;
     }
-
-    do {
-        pthread_mutex_lock(&ctx->vstate.lock);
-        while (ctx->vstate.enable == false) {
-            if(enabled) {
-                int e = 0;
-                if(ioctl(ctx->dpyAttr[dpy].fd, MSMFB_OVERLAY_VSYNC_CTRL,
-                         &e) < 0) {
-                    ALOGE("%s: vsync control failed. Dpy=%d, enabled=%d : %s",
-                          __FUNCTION__, dpy, enabled, strerror(errno));
-                    ret = -errno;
-                }
-                enabled = false;
-            }
-            pthread_cond_wait(&ctx->vstate.cond, &ctx->vstate.lock);
-        }
-        pthread_mutex_unlock(&ctx->vstate.lock);
-
-        if (!enabled) {
-            int e = 1;
-            if(ioctl(ctx->dpyAttr[dpy].fd, MSMFB_OVERLAY_VSYNC_CTRL,
-                                          &e) < 0) {
-                ALOGE("%s: vsync control failed. Dpy=%d, enabled=%d : %s",
-                      __FUNCTION__, dpy, enabled, strerror(errno));
-                ret = -errno;
-            }
-            enabled = true;
-        }
-
-       for(int i = 0; i < MAX_RETRY_COUNT; i++) {
-           len = pread(fd_timestamp, vdata, MAX_DATA, 0);
-           if(len < 0 && (errno == EAGAIN || errno == EINTR)) {
-               ALOGW("%s: vsync read: EAGAIN, retry (%d/%d).",
-                     __FUNCTION__, i, MAX_RETRY_COUNT);
-               continue;
-           } else {
-               break;
-           }
-       }
-
-       if (len < 0) {
+  // Open success - read now
+       len = read(fd_timestamp, vdata, PAGE_SIZE);
+       if (len < 0){
            ALOGE ("FATAL:%s:not able to read file:%s, %s", __FUNCTION__,
-                  vsync_timestamp_fb0, strerror(errno));
-           close (fd_timestamp);
+                (fb1_vsync) ? vsync_timestamp_fb1 : vsync_timestamp_fb0,
+                                                        strerror(errno));
+           fd_timestamp = -1;
            return NULL;
        }
 
-       // extract timestamp
-       const char *str = vdata;
-       if (!strncmp(str, "VSYNC=", strlen("VSYNC="))) {
+      // extract timestamp
+      const char *str = vdata;
+      if (!strncmp(str, "VSYNC=", strlen("VSYNC="))) {
           cur_timestamp = strtoull(str + strlen("VSYNC="), NULL, 0);
-       } else {
-          ALOGE ("FATAL: %s: vsync timestamp not in correct format: [%s]",
-                  __FUNCTION__,
-                  str);
-       }
-       // send timestamp to HAL
-       ALOGD_IF (VSYNC_DEBUG, "%s: timestamp %llu sent to HWC for %s",
-            __FUNCTION__, cur_timestamp, "fb0");
-       ctx->proc->vsync(ctx->proc, dpy, cur_timestamp);
+      } else {
+        ALOGE ("FATAL:%s:timestamp data not in correct format",
+                                                 __FUNCTION__);
+      }
+      // send timestamp to HAL
+      ALOGD_IF (VSYNC_DEBUG, "%s: timestamp %llu sent to HWC for %s",
+            __FUNCTION__, cur_timestamp, (fb1_vsync) ? "fb1" : "fb0");
+      ctx->proc->vsync(ctx->proc, 0, cur_timestamp);
 
-    } while (true);
     if(fd_timestamp >= 0)
         close (fd_timestamp);
 
diff --git a/libhwcomposer/ihwc.cpp b/libhwcomposer/ihwc.cpp
index e69de29..110ff99 100644
--- a/libhwcomposer/ihwc.cpp
+++ b/libhwcomposer/ihwc.cpp
@@ -0,0 +1,231 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012, Code Aurora Forum. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are
+ * retained for attribution purposes only.
+
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdint.h>
+#include <sys/types.h>
+#include <utils/Errors.h>
+
+#include <binder/Parcel.h>
+#include <binder/IBinder.h>
+#include <binder/IInterface.h>
+#include <ihwc.h>
+
+using namespace android;
+
+// ---------------------------------------------------------------------------
+
+namespace hwcService {
+
+class BpHWComposer : public BpInterface<IHWComposer>
+{
+public:
+    BpHWComposer(const sp<IBinder>& impl)
+        : BpInterface<IHWComposer>(impl)
+    {
+    }
+
+    virtual status_t setHPDStatus(int hpdStatus) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IHWComposer::getInterfaceDescriptor());
+        data.writeInt32(hpdStatus);
+        status_t result = remote()->transact(SET_EXT_HPD_ENABLE,
+                                             data, &reply);
+        result = reply.readInt32();
+        return result;
+    }
+
+    virtual status_t setResolutionMode(int resMode) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IHWComposer::getInterfaceDescriptor());
+        data.writeInt32(resMode);
+        status_t result = remote()->transact(SET_EXT_DISPLAY_RESOLUTION_MODE,
+                                             data, &reply);
+        result = reply.readInt32();
+        return result;
+    }
+
+    virtual status_t setActionSafeDimension(int w, int h) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IHWComposer::getInterfaceDescriptor());
+        data.writeInt32(w);
+        data.writeInt32(h);
+        status_t result =
+            remote()->transact(SET_EXT_DISPLAY_ACTIONSAFE_DIMENSIONS,
+                                             data, &reply);
+        result = reply.readInt32();
+        return result;
+    }
+    virtual status_t setOpenSecureStart() {
+        Parcel data, reply;
+        data.writeInterfaceToken(IHWComposer::getInterfaceDescriptor());
+        status_t result = remote()->transact(SET_OPEN_SECURE_START,
+                                             data, &reply);
+        result = reply.readInt32();
+        return result;
+    }
+
+    virtual status_t setOpenSecureEnd() {
+        Parcel data, reply;
+        data.writeInterfaceToken(IHWComposer::getInterfaceDescriptor());
+        status_t result = remote()->transact(SET_OPEN_SECURE_END,
+                                             data, &reply);
+        result = reply.readInt32();
+        return result;
+    }
+
+    virtual status_t setCloseSecureStart() {
+        Parcel data, reply;
+        data.writeInterfaceToken(IHWComposer::getInterfaceDescriptor());
+        status_t result = remote()->transact(SET_CLOSE_SECURE_START,
+                                             data, &reply);
+        result = reply.readInt32();
+        return result;
+    }
+    virtual status_t setCloseSecureEnd() {
+        Parcel data, reply;
+        data.writeInterfaceToken(IHWComposer::getInterfaceDescriptor());
+        status_t result = remote()->transact(SET_CLOSE_SECURE_END,
+                                             data, &reply);
+        result = reply.readInt32();
+        return result;
+    }
+
+    virtual status_t getExternalDisplay(int *extDispType) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IHWComposer::getInterfaceDescriptor());
+        status_t result = remote()->transact(GET_EXT_DISPLAY_TYPE,
+                                             data, &reply);
+        *extDispType = reply.readInt32();
+        result = reply.readInt32();
+        return result;
+    }
+
+    virtual status_t getResolutionModes(int *resModes, int count) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IHWComposer::getInterfaceDescriptor());
+        data.writeInt32(count);
+        status_t result = remote()->transact(GET_EXT_DISPLAY_RESOLUTION_MODES,
+                                             data, &reply);
+        for(int i = 0;i < count;i++) {
+            resModes[i] = reply.readInt32();
+        }
+        result = reply.readInt32();
+        return result;
+    }
+
+    virtual status_t getResolutionModeCount(int *resModeCount) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IHWComposer::getInterfaceDescriptor());
+        status_t result = remote()->transact(
+                          GET_EXT_DISPLAY_RESOLUTION_MODE_COUNT, data, &reply);
+        *resModeCount = reply.readInt32();
+        result = reply.readInt32();
+        return result;
+    }
+};
+
+IMPLEMENT_META_INTERFACE(HWComposer, "android.display.IHWComposer");
+
+// ----------------------------------------------------------------------
+
+status_t BnHWComposer::onTransact(
+    uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
+{
+    // codes that don't require permission check
+    switch(code) {
+        case SET_EXT_HPD_ENABLE: {
+            CHECK_INTERFACE(IHWComposer, data, reply);
+            int hpdStatus = data.readInt32();
+            status_t res = setHPDStatus(hpdStatus);
+            reply->writeInt32(res);
+            return NO_ERROR;
+        } break;
+        case SET_EXT_DISPLAY_RESOLUTION_MODE: {
+            CHECK_INTERFACE(IHWComposer, data, reply);
+            int resMode = data.readInt32();
+            status_t res = setResolutionMode(resMode);
+            reply->writeInt32(res);
+            return NO_ERROR;
+        } break;
+        case SET_EXT_DISPLAY_ACTIONSAFE_DIMENSIONS: {
+            CHECK_INTERFACE(IHWComposer, data, reply);
+            int w = data.readInt32();
+            int h = data.readInt32();
+            status_t res = setActionSafeDimension(w, h);
+            reply->writeInt32(res);
+            return NO_ERROR;
+        } break;
+        case SET_OPEN_SECURE_START: {
+            CHECK_INTERFACE(IHWComposer, data, reply);
+            status_t res = setOpenSecureStart();
+            reply->writeInt32(res);
+            return NO_ERROR;
+        }break;
+        case SET_OPEN_SECURE_END: {
+            CHECK_INTERFACE(IHWComposer, data, reply);
+            status_t res = setOpenSecureEnd();
+            reply->writeInt32(res);
+            return NO_ERROR;
+        }break;
+        case SET_CLOSE_SECURE_START: {
+            CHECK_INTERFACE(IHWComposer, data, reply);
+            status_t res = setCloseSecureStart();
+            reply->writeInt32(res);
+            return NO_ERROR;
+        }break;
+        case SET_CLOSE_SECURE_END: {
+            CHECK_INTERFACE(IHWComposer, data, reply);
+            status_t res = setCloseSecureEnd();
+            reply->writeInt32(res);
+            return NO_ERROR;
+        }break;
+        case GET_EXT_DISPLAY_TYPE: {
+            CHECK_INTERFACE(IHWComposer, data, reply);
+            int extDispType;
+            status_t res = getExternalDisplay(&extDispType);
+            reply->writeInt32(extDispType);
+            reply->writeInt32(res);
+            return NO_ERROR;
+        } break;
+        case GET_EXT_DISPLAY_RESOLUTION_MODES: {
+            CHECK_INTERFACE(IHWComposer, data, reply);
+            int count = data.readInt32();
+            int resModes[64];
+            status_t res = getResolutionModes(&resModes[0]);
+            for(int i = 0;i < count;i++) {
+                reply->writeInt32(resModes[i]);
+            }
+            reply->writeInt32(res);
+            return NO_ERROR;
+        } break;
+        case GET_EXT_DISPLAY_RESOLUTION_MODE_COUNT: {
+            CHECK_INTERFACE(IHWComposer, data, reply);
+            int resModeCount;
+            status_t res = getResolutionModeCount(&resModeCount);
+            reply->writeInt32(resModeCount);
+            reply->writeInt32(res);
+            return NO_ERROR;
+        } break;
+        default:
+            return BBinder::onTransact(code, data, reply, flags);
+    }
+}
+
+}; // namespace hwcService
diff --git a/libhwcomposer/ihwc.h b/libhwcomposer/ihwc.h
index e69de29..70b96ef 100644
--- a/libhwcomposer/ihwc.h
+++ b/libhwcomposer/ihwc.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012, Code Aurora Forum. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are
+ * retained for attribution purposes only.
+
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_IHWCOMPOSER_H
+#define ANDROID_IHWCOMPOSER_H
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#include <utils/Errors.h>
+#include <utils/RefBase.h>
+
+#include <binder/IInterface.h>
+
+
+namespace hwcService {
+// ----------------------------------------------------------------------------
+enum {
+    SET_EXT_HPD_ENABLE = 0,
+    SET_EXT_DISPLAY_RESOLUTION_MODE,
+    SET_EXT_DISPLAY_ACTIONSAFE_DIMENSIONS,
+    SET_OPEN_SECURE_START,
+    SET_OPEN_SECURE_END,
+    SET_CLOSE_SECURE_START,
+    SET_CLOSE_SECURE_END,
+    GET_EXT_DISPLAY_TYPE,
+    GET_EXT_DISPLAY_RESOLUTION_MODES,
+    GET_EXT_DISPLAY_RESOLUTION_MODE_COUNT,
+};
+
+class IHWComposer : public android::IInterface
+{
+public:
+    DECLARE_META_INTERFACE(HWComposer);
+
+    virtual android::status_t getResolutionModeCount(int *modeCount) = 0;
+    virtual android::status_t getResolutionModes(int *EDIDModes,
+                                                 int count = 1) = 0;
+    virtual android::status_t getExternalDisplay(int *extDisp) = 0;
+
+    virtual android::status_t setHPDStatus(int enable) = 0;
+    virtual android::status_t setResolutionMode(int resMode) = 0;
+    virtual android::status_t setActionSafeDimension(int w, int h) = 0;
+    // Secure Intent Hooks
+    virtual android::status_t setOpenSecureStart() = 0;
+    virtual android::status_t setOpenSecureEnd() = 0;
+    virtual android::status_t setCloseSecureStart() = 0;
+    virtual android::status_t setCloseSecureEnd() = 0;
+};
+
+// ----------------------------------------------------------------------------
+
+class BnHWComposer : public android::BnInterface<IHWComposer>
+{
+public:
+    virtual android::status_t onTransact( uint32_t code,
+                                          const android::Parcel& data,
+                                          android::Parcel* reply,
+                                          uint32_t flags = 0);
+};
+
+// ----------------------------------------------------------------------------
+}; // namespace hwcService
+
+#endif // ANDROID_IHWCOMPOSER_H
diff --git a/liboverlay/mdpWrapper.h b/liboverlay/mdpWrapper.h
index b1eb76c..40b8840 100644
--- a/liboverlay/mdpWrapper.h
+++ b/liboverlay/mdpWrapper.h
@@ -247,12 +247,6 @@ inline void dump(const char* const s, const msm_rotator_img_info& rot) {
     dump("src_rect", rot.src_rect);
 }
 inline void dump(const char* const s, const msm_rotator_data_info& rot) {
-    ALOGE("%s msm_rotator_data_info sessid=%d verkey=%d",
-            s, rot.session_id, rot.version_key);
-    dump("src", rot.src);
-    dump("dst", rot.dst);
-    dump("src_chroma", rot.src_chroma);
-    dump("dst_chroma", rot.dst_chroma);
 }
 inline void dump(const char* const s, const fb_fix_screeninfo& finfo) {
     ALOGE("%s fb_fix_screeninfo type=%d", s, finfo.type);
diff --git a/liboverlay/overlayMem.h b/liboverlay/overlayMem.h
index 60ed8fe..af66825 100644
--- a/liboverlay/overlayMem.h
+++ b/liboverlay/overlayMem.h
@@ -108,7 +108,7 @@ inline OvMem::OvMem() {
     mAllocType = 0;
     mBufSz = 0;
     mNumBuffers = 0;
-    mAlloc = gralloc::IAllocController::getInstance();
+    mAlloc = gralloc::IAllocController::getInstance(false);
 }
 
 inline OvMem::~OvMem() { }
@@ -136,12 +136,12 @@ inline bool OvMem::open(uint32_t numbufs,
     data.align = getpagesize();
     data.uncached = true;
 
-    err = mAlloc->allocate(data, allocFlags);
+    err = mAlloc->allocate(data, allocFlags, 0);
     //see if we can fallback to other heap
     //we can try MM_HEAP once if it's not secure playback
     if (err != 0 && !isSecure) {
         allocFlags |= GRALLOC_USAGE_PRIVATE_MM_HEAP;
-        err = mAlloc->allocate(data, allocFlags);
+        err = mAlloc->allocate(data, allocFlags, 0);
         if (err != 0) {
             ALOGE(" could not allocate from fallback heap");
             return false;
diff --git a/liboverlay/overlayRotator.h b/liboverlay/overlayRotator.h
index 075e46d..f5538db 100644
--- a/liboverlay/overlayRotator.h
+++ b/liboverlay/overlayRotator.h
@@ -448,7 +448,7 @@ inline uint32_t MdssRot::getDstOffset() const {
 }
 inline uint32_t MdssRot::getSessId() const { return mRotInfo.id; }
 inline void MdssRot::setSrcFB() {
-    mRotData.data.flags |= MDP_MEMORY_ID_TYPE_FB;
+    mRotData.dst_data.flags |= MDP_MEMORY_ID_TYPE_FB;
 }
 
 } // overlay
diff --git a/libqdutils/cb_utils.cpp b/libqdutils/cb_utils.cpp
index e69de29..5660759 100644
--- a/libqdutils/cb_utils.cpp
+++ b/libqdutils/cb_utils.cpp
@@ -0,0 +1,134 @@
+/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Code Aurora Forum, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <gralloc_priv.h>
+#include "stdio.h"
+#include <comptype.h>
+#include "hwc_utils.h"
+#include "qcom_ui.h"
+#include <cutils/memory.h>
+
+namespace qdutils {
+
+bool CBUtils::sGPUlayerpresent = 0;
+
+void CBUtils::checkforGPULayer(const hwc_layer_list_t* list) {
+    sGPUlayerpresent =  false;
+    if (!list) return;
+    for(uint32_t index = 0; index < list->numHwLayers; index++) {
+        const hwc_layer_t* layer = &list->hwLayers[index];
+        if(layer->compositionType == HWC_FRAMEBUFFER) {
+           sGPUlayerpresent =  true;
+           break;
+        }
+        if(layer->flags & HWC_SKIP_LAYER) {
+           sGPUlayerpresent =  true;
+           break;
+        }
+    }
+}
+
+/*
+ * Checks if FB is updated by this composition type
+ *
+ * @param: composition type
+ * @return: true if FB is updated, false if not
+ */
+
+bool CBUtils::isUpdatingFB(int Type)
+{
+    switch((qhwc::HWCCompositionType)Type)
+    {
+        case qhwc::HWC_USE_COPYBIT:
+            return true;
+        default:
+            ALOGE("%s: invalid composition type(%d)", __FUNCTION__, Type);
+            return false;
+    };
+};
+
+/*
+ * Clear Region implementation for C2D/MDP versions.
+ *
+ * @param: region to be cleared
+ * @param: EGL Display
+ * @param: EGL Surface
+ *
+ * @return 0 on success
+ */
+
+int CBUtils::qcomuiClearRegion(Region region, EGLDisplay dpy){
+
+    int ret = 0;
+    if (sGPUlayerpresent) {
+        //return ERROR when any layer is flagged for GPU composition.
+        return -1;
+    }
+
+
+
+    android_native_buffer_t *renderBuffer =
+          qdutils::eglHandles::getInstance().getAndroidNativeRenderBuffer(dpy);
+
+    if (!renderBuffer) {
+        ALOGE("%s: eglGetRenderBufferANDROID returned NULL buffer",
+             __FUNCTION__);
+        return -1;
+    }
+   private_handle_t *fbHandle = (private_handle_t *)renderBuffer->handle;
+    if(!fbHandle) {
+        ALOGE("%s: Framebuffer handle is NULL", __FUNCTION__);
+        return -1;
+    }
+
+    int bytesPerPixel = 4;
+    if (HAL_PIXEL_FORMAT_RGB_565 == fbHandle->format) {
+        bytesPerPixel = 2;
+    }
+
+    Region::const_iterator it = region.begin();
+    Region::const_iterator const end = region.end();
+    const int32_t stride = renderBuffer->stride*bytesPerPixel;
+    while (it != end) {
+        const Rect& r = *it++;
+        uint8_t* dst = (uint8_t*) fbHandle->base +
+            (r.left + r.top*renderBuffer->stride)*bytesPerPixel;
+        int w = r.width()*bytesPerPixel;
+        int h = r.height();
+
+        do {
+            if(4 == bytesPerPixel){
+                android_memset32((uint32_t*)dst, 0, w);
+            } else {
+                android_memset16((uint16_t*)dst, 0, w);
+            }
+            dst += stride;
+        } while(--h);
+    }
+    return 0;
+}
+} //namespace
diff --git a/libqdutils/egl_handles.cpp b/libqdutils/egl_handles.cpp
index e69de29..d8a15de 100644
--- a/libqdutils/egl_handles.cpp
+++ b/libqdutils/egl_handles.cpp
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012, Code Aurora Forum. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#include <cutils/log.h>
+#include <fcntl.h>
+#include "egl_handles.h"
+#include <dlfcn.h>
+
+ANDROID_SINGLETON_STATIC_INSTANCE(qdutils::eglHandles);
+namespace qdutils {
+
+eglHandles::eglHandles(){
+     LINK_eglGetRenderBufferANDROID = NULL ;
+     LINK_eglGetCurrentSurface = NULL;
+     egl_lib = NULL;
+     openEglLibAndGethandle();
+     updateEglHandles(egl_lib);
+}
+
+eglHandles::~eglHandles(){
+    closeEglLib();
+
+}
+
+void eglHandles::updateEglHandles(void* egl_lib){
+
+    if(egl_lib != NULL) {
+        *(void **)&LINK_eglGetRenderBufferANDROID =
+                             ::dlsym(egl_lib, "eglGetRenderBufferANDROID");
+        *(void **)&LINK_eglGetCurrentSurface =
+                                  ::dlsym(egl_lib, "eglGetCurrentSurface");
+         if(LINK_eglGetRenderBufferANDROID == NULL ||
+                      LINK_eglGetCurrentSurface == NULL)
+               ALOGE(" %s::Unable to  find symbols",__FUNCTION__) ;
+    }else {
+        LINK_eglGetRenderBufferANDROID = NULL;
+        LINK_eglGetCurrentSurface = NULL;
+    }
+}
+
+void eglHandles::openEglLibAndGethandle(){
+
+    egl_lib = ::dlopen("libEGL_adreno200.so", RTLD_GLOBAL | RTLD_LAZY);
+    if (!egl_lib) {
+        ALOGE(" %s::Unable to open libEGL_adreno200",__FUNCTION__) ;
+    }
+}
+
+android_native_buffer_t *
+      eglHandles::getAndroidNativeRenderBuffer(EGLDisplay dpy){
+
+  if(LINK_eglGetRenderBufferANDROID == NULL ||
+        LINK_eglGetCurrentSurface == NULL){
+           ALOGE("%s:: Unable to load or find the symbols ",__FUNCTION__);
+           return NULL;
+  }
+  EGLSurface eglSurface = LINK_eglGetCurrentSurface(EGL_DRAW);
+  android_native_buffer_t *renderBuffer =
+    (android_native_buffer_t*)LINK_eglGetRenderBufferANDROID(dpy, eglSurface);
+  return renderBuffer;
+}
+
+void eglHandles ::closeEglLib(){
+    if(egl_lib)
+        ::dlclose(egl_lib);
+    egl_lib = NULL;
+    updateEglHandles(NULL);
+}
+
+};
+
+
+
diff --git a/libqdutils/egl_handles.h b/libqdutils/egl_handles.h
index e69de29..c5fb244 100644
--- a/libqdutils/egl_handles.h
+++ b/libqdutils/egl_handles.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012, Code Aurora Forum. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef EGL_HANDLES_H
+#define EGL_HANDLES_H
+
+#include <stdint.h>
+#include <utils/Singleton.h>
+#include <EGL/egl.h>
+#include <gralloc_priv.h>
+#include <EGL/eglext.h>
+
+typedef EGLClientBuffer (*functype_eglGetRenderBufferANDROID) (
+                                             EGLDisplay dpy,
+                                            EGLSurface draw);
+typedef EGLSurface (*functype_eglGetCurrentSurface)(EGLint readdraw);
+
+using namespace android;
+namespace qdutils {
+class eglHandles : public Singleton <eglHandles>
+{
+
+  functype_eglGetRenderBufferANDROID LINK_eglGetRenderBufferANDROID;
+  functype_eglGetCurrentSurface LINK_eglGetCurrentSurface;
+  void* egl_lib;
+
+  void updateEglHandles(void* egl_lib);
+  void openEglLibAndGethandle();
+  void closeEglLib();
+
+public :
+   eglHandles();
+   ~eglHandles();
+   functype_eglGetRenderBufferANDROID getEGLRenderBufferANDROID(){
+        return LINK_eglGetRenderBufferANDROID;
+   }
+   functype_eglGetCurrentSurface getEGLCurrentSurface(){
+        return LINK_eglGetCurrentSurface;
+   }
+   android_native_buffer_t *getAndroidNativeRenderBuffer(EGLDisplay dpy);
+};
+};
+#endif // end of EGL_HANDLES_H
+
+
diff --git a/libqdutils/gpuformats.h b/libqdutils/gpuformats.h
index e69de29..cf88d35 100644
--- a/libqdutils/gpuformats.h
+++ b/libqdutils/gpuformats.h
@@ -0,0 +1,52 @@
+/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Code Aurora Forum, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef QCOM_GPUFORMATS_H
+#define QCOM_GPUFORMATS_H
+#include <gralloc_priv.h>
+
+namespace qdutils {
+/*
+ * Checks if the format is supported by the GPU.
+ *
+ * @param: format to check
+ *
+ * @return true if the format is supported by the GPU.
+ */
+static inline bool isGPUSupportedFormat(int format)
+{
+    if ((format == HAL_PIXEL_FORMAT_RGB_888)      ||
+        (format == HAL_PIXEL_FORMAT_YCrCb_422_SP) ||
+        (format == HAL_PIXEL_FORMAT_YCbCr_422_SP)) {
+        return false;
+    }
+    return true;
+}
+}; //namespace qdutils
+
+
+
+#endif /* end of include guard: QCOM_GPUFORMATS_H */
diff --git a/libqdutils/qcom_ui.h b/libqdutils/qcom_ui.h
index e69de29..a2dd166 100755
--- a/libqdutils/qcom_ui.h
+++ b/libqdutils/qcom_ui.h
@@ -0,0 +1,48 @@
+/* Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Code Aurora Forum, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef QCOM_UTIL_H
+#define QCOM_UTIL_H
+
+#include <gralloc_priv.h>
+#include <comptype.h>
+#include <ui/Region.h>
+#include <hardware/hwcomposer.h>
+#include "egl_handles.h"
+
+namespace qdutils {
+class CBUtils {
+
+private:
+  static bool sGPUlayerpresent;
+
+public:
+  static void checkforGPULayer(const hwc_layer_list_t* list);
+  static bool isUpdatingFB(int compositionType);
+  static int qcomuiClearRegion(Region region, EGLDisplay dpy);
+};
+}//namespace qdutils
+#endif /* end of include guard: QCOM_UTIL_H*/
